[
  {
    "ruleId": "arch-smart-dumb-components",
    "ruleTitle": "Use Smart and Dumb Component Pattern",
    "type": "bad",
    "code": "// ❌ One component handles data, logic, AND presentation\n@Component({\n  selector: 'app-user-dashboard',\n  template: `\n    <div class=\"dashboard\">\n      <h1>Welcome, {{ user?.name }}</h1>\n      @if (loading) {\n        <div class=\"spinner\">Loading...</div>\n      }\n      @for (order of orders; track order.id) {\n        <div class=\"order-card\" [class.urgent]=\"isUrgent(order)\">\n          <h3>Order #{{ order.id }}</h3>\n          <p>{{ order.date | date }}</p>\n          <p>{{ formatPrice(order.total) }}</p>\n          <button (click)=\"cancelOrder(order)\">Cancel</button>\n          <button (click)=\"viewDetails(order)\">Details</button>\n        </div>\n      }\n      <form [formGroup]=\"filterForm\" (ngSubmit)=\"applyFilters()\">\n        <!-- complex filter form -->\n      </form>\n    </div>\n  `\n})\nexport class UserDashboardComponent implements OnInit {\n  user: User | null = null;\n  orders: Order[] = [];\n  loading = true;\n  filterForm: FormGroup;\n\n  constructor(\n    private userService: UserService,\n    private orderService: OrderService,\n    private router: Router,\n    private fb: FormBuilder,\n    private analytics: AnalyticsService\n  ) {\n    this.filterForm = this.fb.group({...});\n  }\n\n  ngOnInit() {\n    this.loadUser();\n    this.loadOrders();\n  }\n\n  loadUser() { /* ... */ }\n  loadOrders() { /* ... */ }\n  isUrgent(order: Order): boolean { /* ... */ }\n  formatPrice(price: number): string { /* ... */ }\n  cancelOrder(order: Order) { /* ... */ }\n  viewDetails(order: Order) { /* ... */ }\n  applyFilters() { /* ... */ }\n  // 500+ lines of mixed concerns\n}",
    "language": "typescript",
    "description": "God component doing everything"
  },
  {
    "ruleId": "arch-smart-dumb-components",
    "ruleTitle": "Use Smart and Dumb Component Pattern",
    "type": "good",
    "code": "// ✅ DUMB Component - single order card\n@Component({\n  selector: 'app-order-card',\n  template: `\n    <div class=\"order-card\" [class.urgent]=\"isUrgent()\">\n      <h3>Order #{{ order().id }}</h3>\n      <p>{{ order().date | date }}</p>\n      <p>{{ order().total | currency }}</p>\n      <button (click)=\"cancel.emit()\">Cancel</button>\n      <button (click)=\"viewDetails.emit()\">Details</button>\n    </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class OrderCardComponent {\n  order = input.required<Order>();\n\n  cancel = output<void>();\n  viewDetails = output<void>();\n\n  // Pure computation, no side effects\n  isUrgent = computed(() => {\n    const daysOld = this.getDaysOld(this.order().date);\n    return this.order().status === 'pending' && daysOld > 3;\n  });\n\n  private getDaysOld(date: Date): number {\n    return Math.floor((Date.now() - date.getTime()) / (1000 * 60 * 60 * 24));\n  }\n}",
    "language": "typescript",
    "description": "Smart + Dumb separation"
  },
  {
    "ruleId": "bundle-no-barrel-imports",
    "ruleTitle": "Avoid Barrel File Imports",
    "type": "bad",
    "code": "// Even worse - wildcard imports\nimport * as Services from './services';\n\n// Using only one service, but entire barrel is included\nconstructor(private userService: Services.UserService) {}",
    "language": "typescript",
    "description": "Barrel imports"
  },
  {
    "ruleId": "bundle-no-barrel-imports",
    "ruleTitle": "Avoid Barrel File Imports",
    "type": "good",
    "code": "// For commonly used utilities, create small focused barrels\n// utils/date/index.ts - small, focused barrel (OK)\nexport { formatDate } from './format-date';\nexport { parseDate } from './parse-date';\n\n// utils/string/index.ts - separate barrel for strings\nexport { capitalize } from './capitalize';\nexport { truncate } from './truncate';\n\n// Instead of one massive utils/index.ts",
    "language": "typescript",
    "description": "Direct imports"
  },
  {
    "ruleId": "bundle-no-barrel-imports",
    "ruleTitle": "Avoid Barrel File Imports",
    "type": "good",
    "code": "// Consumer code - tree-shakeable imports\nimport { Button } from '@myorg/ui-components/button';\n// Only button code is bundled",
    "language": "typescript",
    "description": "Package exports for libraries"
  },
  {
    "ruleId": "change-detach-reattach",
    "ruleTitle": "Detach Change Detector for Heavy Operations",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-animation',\n  template: `<canvas #canvas></canvas>`\n})\nexport class AnimationComponent implements OnInit {\n  @ViewChild('canvas') canvas!: ElementRef<HTMLCanvasElement>;\n\n  ngOnInit() {\n    this.animate();\n  }\n\n  animate() {\n    this.drawFrame();\n    requestAnimationFrame(() => this.animate());\n    // Each frame causes unnecessary change detection\n  }\n}",
    "language": "typescript",
    "description": "Change detection runs during animation"
  },
  {
    "ruleId": "change-detach-reattach",
    "ruleTitle": "Detach Change Detector for Heavy Operations",
    "type": "good",
    "code": "@Component({\n  selector: 'app-animation',\n  template: `\n    <canvas #canvas></canvas>\n    <p>FPS: {{ fps }}</p>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class AnimationComponent implements OnInit {\n  @ViewChild('canvas') canvas!: ElementRef<HTMLCanvasElement>;\n  fps = 0;\n\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  ngOnInit() {\n    this.cdr.detach();  // Exclude from change detection\n    this.animate();\n    this.updateFps();\n  }\n\n  animate() {\n    this.drawFrame();\n    requestAnimationFrame(() => this.animate());\n  }\n\n  updateFps() {\n    setInterval(() => {\n      this.cdr.detectChanges();  // Manual update only when needed\n    }, 1000);\n  }\n}",
    "language": "typescript",
    "description": "Detach during animation"
  },
  {
    "ruleId": "change-onpush",
    "ruleTitle": "Use OnPush Change Detection Strategy",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-user-list',\n  template: `\n    @for (user of users; track user.id) {\n      <!-- formatDate called on EVERY change detection cycle -->\n      <span>{{ formatDate(user.created) }}</span>\n    }\n  `\n})\nexport class UserListComponent {\n  @Input() users: User[] = [];\n\n  formatDate(date: Date): string {\n    return new Intl.DateTimeFormat('en-US').format(date);\n  }\n}",
    "language": "typescript",
    "description": "Default checks on every cycle"
  },
  {
    "ruleId": "change-onpush",
    "ruleTitle": "Use OnPush Change Detection Strategy",
    "type": "good",
    "code": "@Component({\n  selector: 'app-user-list',\n  template: `\n    @for (user of users; track user.id) {\n      <span>{{ user.created | date }}</span>\n    }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserListComponent {\n  @Input() users: User[] = [];\n  // Component only checks when users reference changes\n  // Use pure pipes instead of methods in templates\n}",
    "language": "typescript",
    "description": "OnPush limits checks"
  },
  {
    "ruleId": "change-run-outside-zone",
    "ruleTitle": "Run Non-UI Code Outside NgZone",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-scroll-tracker',\n  template: `<div>Scroll position logged to console</div>`\n})\nexport class ScrollTrackerComponent implements OnInit {\n  ngOnInit() {\n    // Every scroll event triggers change detection\n    window.addEventListener('scroll', this.onScroll);\n  }\n\n  onScroll = () => {\n    console.log('Scroll:', window.scrollY);  // No UI update needed\n  };\n}",
    "language": "typescript",
    "description": "Event listener triggers change detection"
  },
  {
    "ruleId": "change-run-outside-zone",
    "ruleTitle": "Run Non-UI Code Outside NgZone",
    "type": "good",
    "code": "@Component({\n  selector: 'app-scroll-tracker',\n  template: `<div>Scroll position: {{ scrollPosition }}</div>`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ScrollTrackerComponent implements OnInit {\n  scrollPosition = 0;\n\n  constructor(\n    private ngZone: NgZone,\n    private cdr: ChangeDetectorRef\n  ) {}\n\n  ngOnInit() {\n    this.ngZone.runOutsideAngular(() => {\n      window.addEventListener('scroll', this.onScroll);\n    });\n  }\n\n  onScroll = () => {\n    const newPosition = window.scrollY;\n    if (Math.abs(newPosition - this.scrollPosition) > 100) {\n      this.ngZone.run(() => {\n        this.scrollPosition = newPosition;\n        this.cdr.markForCheck();\n      });\n    }\n  };\n}",
    "language": "typescript",
    "description": "Run outside zone, enter for UI updates"
  },
  {
    "ruleId": "css-content-visibility",
    "ruleTitle": "Use CSS content-visibility for Off-Screen Content",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-message-list',\n  template: `\n    <div class=\"messages\">\n      <!-- All 1000 messages rendered and laid out immediately -->\n      @for (message of messages; track message.id) {\n        <div class=\"message\">\n          <app-avatar [user]=\"message.author\" />\n          <div class=\"content\">{{ message.text }}</div>\n          <span class=\"time\">{{ message.time | date:'short' }}</span>\n        </div>\n      }\n    </div>\n  `,\n  styles: [`\n    .message {\n      padding: 12px;\n      border-bottom: 1px solid #eee;\n    }\n  `]\n})\nexport class MessageListComponent {\n  messages: Message[] = []; // 1000+ messages\n}",
    "language": "typescript",
    "description": "renders all items immediately"
  },
  {
    "ruleId": "css-content-visibility",
    "ruleTitle": "Use CSS content-visibility for Off-Screen Content",
    "type": "good",
    "code": "@Component({\n  selector: 'app-message-list',\n  template: `\n    <div class=\"messages\">\n      @for (message of messages; track message.id) {\n        <div class=\"message\">\n          <app-avatar [user]=\"message.author\" />\n          <div class=\"content\">{{ message.text }}</div>\n          <span class=\"time\">{{ message.time | date:'short' }}</span>\n        </div>\n      }\n    </div>\n  `,\n  styles: [`\n    .message {\n      padding: 12px;\n      border-bottom: 1px solid #eee;\n\n      /* ✅ Skip layout/paint for off-screen items */\n      content-visibility: auto;\n\n      /* Hint at size to prevent layout shift when scrolling */\n      contain-intrinsic-size: 0 80px;\n    }\n  `]\n})\nexport class MessageListComponent {\n  messages: Message[] = []; // 1000+ messages - no problem!\n}",
    "language": "typescript",
    "description": "defers off-screen rendering"
  },
  {
    "ruleId": "js-combine-iterations",
    "ruleTitle": "Combine Multiple Array Iterations",
    "type": "bad",
    "code": "@Component({...})\nexport class UserStatsComponent {\n  users: User[] = [];\n\n  getStats() {\n    // ❌ Iterates users array 3 times\n    const admins = this.users.filter(u => u.role === 'admin');\n    const activeUsers = this.users.filter(u => u.isActive);\n    const totalAge = this.users.reduce((sum, u) => sum + u.age, 0);\n\n    return { admins, activeUsers, averageAge: totalAge / this.users.length };\n  }\n}",
    "language": "typescript",
    "description": "3 iterations over same array"
  },
  {
    "ruleId": "js-combine-iterations",
    "ruleTitle": "Combine Multiple Array Iterations",
    "type": "good",
    "code": "@Component({...})\nexport class UserStatsComponent {\n  users: User[] = [];\n\n  getStats() {\n    // ✅ Single iteration, multiple results\n    const admins: User[] = [];\n    const activeUsers: User[] = [];\n    let totalAge = 0;\n\n    for (const user of this.users) {\n      if (user.role === 'admin') admins.push(user);\n      if (user.isActive) activeUsers.push(user);\n      totalAge += user.age;\n    }\n\n    return { admins, activeUsers, averageAge: totalAge / this.users.length };\n  }\n}",
    "language": "typescript",
    "description": "1 iteration"
  },
  {
    "ruleId": "js-set-map-lookups",
    "ruleTitle": "Use Set/Map for O(1) Lookups",
    "type": "bad",
    "code": "@Component({...})\nexport class UserListComponent {\n  users: User[] = [];\n  selectedIds: string[] = [];\n\n  isSelected(userId: string): boolean {\n    // ❌ O(n) - scans entire array for each check\n    return this.selectedIds.includes(userId);\n  }\n\n  // With 1000 users and 100 selected, this is 100,000 comparisons\n  // Called on every change detection cycle!\n}",
    "language": "typescript"
  },
  {
    "ruleId": "js-set-map-lookups",
    "ruleTitle": "Use Set/Map for O(1) Lookups",
    "type": "good",
    "code": "@Component({...})\nexport class UserListComponent {\n  users: User[] = [];\n  selectedIds = new Set<string>();\n\n  isSelected(userId: string): boolean {\n    // ✅ O(1) - instant hash lookup\n    return this.selectedIds.has(userId);\n  }\n\n  toggleSelection(userId: string) {\n    if (this.selectedIds.has(userId)) {\n      this.selectedIds.delete(userId);\n    } else {\n      this.selectedIds.add(userId);\n    }\n  }\n}",
    "language": "typescript"
  },
  {
    "ruleId": "perf-memory-leaks",
    "ruleTitle": "Prevent Memory Leaks",
    "type": "bad",
    "code": "// ❌ Subscription lives forever after component destroyed\n@Component({...})\nexport class DashboardComponent implements OnInit {\n  ngOnInit() {\n    // This subscription NEVER gets cleaned up\n    this.dataService.getData().subscribe(data => {\n      this.data = data;\n    });\n\n    // Interval runs forever, even after navigation\n    setInterval(() => this.refresh(), 5000);\n\n    // Event listener never removed\n    window.addEventListener('resize', this.onResize);\n  }\n\n  onResize = () => {\n    this.width = window.innerWidth;\n  };\n}",
    "language": "typescript",
    "description": "Subscription not cleaned up"
  },
  {
    "ruleId": "perf-memory-leaks",
    "ruleTitle": "Prevent Memory Leaks",
    "type": "good",
    "code": "// ✅ Modern approach: takeUntilDestroyed (Angular 16+)\n@Component({...})\nexport class DashboardComponent {\n  private destroyRef = inject(DestroyRef);\n\n  data$ = this.dataService.getData().pipe(\n    takeUntilDestroyed(this.destroyRef)\n  );\n\n  constructor() {\n    // Auto-cleaned up when component destroys\n    interval(5000).pipe(\n      takeUntilDestroyed(this.destroyRef)\n    ).subscribe(() => this.refresh());\n  }\n}\n\n// ✅ Classic approach: Subject + takeUntil\n@Component({...})\nexport class DashboardComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  ngOnInit() {\n    this.dataService.getData().pipe(\n      takeUntil(this.destroy$)\n    ).subscribe(data => this.data = data);\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}",
    "language": "typescript",
    "description": "Proper cleanup"
  },
  {
    "ruleId": "perf-memory-leaks",
    "ruleTitle": "Prevent Memory Leaks",
    "type": "bad",
    "code": "// ❌ setInterval runs forever\n@Component({...})\nexport class PollingComponent implements OnInit {\n  ngOnInit() {\n    setInterval(() => {\n      this.fetchData(); // Runs even after component destroyed!\n    }, 3000);\n  }\n}",
    "language": "typescript",
    "description": "Timer/Interval not cleared"
  },
  {
    "ruleId": "perf-memory-leaks",
    "ruleTitle": "Prevent Memory Leaks",
    "type": "good",
    "code": "// ✅ Option 1: Use RxJS interval with takeUntilDestroyed\n@Component({...})\nexport class PollingComponent {\n  private destroyRef = inject(DestroyRef);\n\n  constructor() {\n    interval(3000).pipe(\n      takeUntilDestroyed(this.destroyRef),\n      switchMap(() => this.dataService.fetch())\n    ).subscribe(data => this.data = data);\n  }\n}\n\n// ✅ Option 2: Manual cleanup with clearInterval\n@Component({...})\nexport class PollingComponent implements OnInit, OnDestroy {\n  private intervalId?: ReturnType<typeof setInterval>;\n\n  ngOnInit() {\n    this.intervalId = setInterval(() => this.fetchData(), 3000);\n  }\n\n  ngOnDestroy() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n}\n\n// ✅ Option 3: setTimeout with recursive call\n@Component({...})\nexport class PollingComponent implements OnDestroy {\n  private timeoutId?: ReturnType<typeof setTimeout>;\n  private isDestroyed = false;\n\n  ngOnInit() {\n    this.poll();\n  }\n\n  private poll() {\n    if (this.isDestroyed) return;\n\n    this.fetchData();\n    this.timeoutId = setTimeout(() => this.poll(), 3000);\n  }\n\n  ngOnDestroy() {\n    this.isDestroyed = true;\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n    }\n  }\n}",
    "language": "typescript",
    "description": "Clear timers"
  },
  {
    "ruleId": "perf-memory-leaks",
    "ruleTitle": "Prevent Memory Leaks",
    "type": "bad",
    "code": "// ❌ Window listener persists forever\n@Component({...})\nexport class ResponsiveComponent implements OnInit {\n  ngOnInit() {\n    window.addEventListener('resize', this.handleResize);\n    document.addEventListener('click', this.handleClick);\n  }\n\n  handleResize = () => { /* ... */ };\n  handleClick = () => { /* ... */ };\n}",
    "language": "typescript",
    "description": "Event listener not removed"
  },
  {
    "ruleId": "perf-memory-leaks",
    "ruleTitle": "Prevent Memory Leaks",
    "type": "good",
    "code": "// ✅ Option 1: Manual cleanup\n@Component({...})\nexport class ResponsiveComponent implements OnInit, OnDestroy {\n  // Must use arrow function or bind to keep 'this' reference\n  private handleResize = () => {\n    this.width = window.innerWidth;\n  };\n\n  ngOnInit() {\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  ngOnDestroy() {\n    window.removeEventListener('resize', this.handleResize);\n  }\n}\n\n// ✅ Option 2: RxJS fromEvent (recommended)\n@Component({...})\nexport class ResponsiveComponent {\n  private destroyRef = inject(DestroyRef);\n\n  width$ = fromEvent(window, 'resize').pipe(\n    debounceTime(100),\n    map(() => window.innerWidth),\n    startWith(window.innerWidth),\n    takeUntilDestroyed(this.destroyRef)\n  );\n}\n\n// ✅ Option 3: Renderer2 for SSR compatibility\n@Component({...})\nexport class ResponsiveComponent implements OnInit, OnDestroy {\n  private renderer = inject(Renderer2);\n  private unlistenFn?: () => void;\n\n  ngOnInit() {\n    this.unlistenFn = this.renderer.listen('window', 'resize', () => {\n      this.width = window.innerWidth;\n    });\n  }\n\n  ngOnDestroy() {\n    this.unlistenFn?.();\n  }\n}",
    "language": "typescript",
    "description": "Remove listeners"
  },
  {
    "ruleId": "perf-memory-leaks",
    "ruleTitle": "Prevent Memory Leaks",
    "type": "bad",
    "code": "// ❌ Service holds reference to destroyed component\n@Injectable({ providedIn: 'root' })\nexport class ModalService {\n  private openModals: ModalComponent[] = [];\n\n  register(modal: ModalComponent) {\n    this.openModals.push(modal);\n    // Never removed - component reference held forever!\n  }\n}",
    "language": "typescript",
    "description": "Holding references to destroyed elements"
  },
  {
    "ruleId": "perf-memory-leaks",
    "ruleTitle": "Prevent Memory Leaks",
    "type": "good",
    "code": "// ✅ Properly manage references\n@Injectable({ providedIn: 'root' })\nexport class ModalService {\n  private openModals = new Set<ModalComponent>();\n\n  register(modal: ModalComponent) {\n    this.openModals.add(modal);\n  }\n\n  unregister(modal: ModalComponent) {\n    this.openModals.delete(modal);\n  }\n}\n\n@Component({...})\nexport class ModalComponent implements OnDestroy {\n  private modalService = inject(ModalService);\n\n  constructor() {\n    this.modalService.register(this);\n  }\n\n  ngOnDestroy() {\n    this.modalService.unregister(this);\n  }\n}",
    "language": "typescript",
    "description": "Clean up references"
  },
  {
    "ruleId": "perf-web-workers",
    "ruleTitle": "Offload Heavy Computation to Web Workers",
    "type": "bad",
    "code": "@Component({\n  template: `\n    <button (click)=\"processData()\">Process</button>\n    <div>Result: {{ result }}</div>\n    <!-- UI freezes while processing -->\n  `\n})\nexport class DataProcessorComponent {\n  result = '';\n\n  processData() {\n    // Blocks main thread for seconds\n    const data = this.generateLargeDataset();\n    this.result = this.heavyComputation(data);\n  }\n}",
    "language": "typescript",
    "description": "Heavy computation blocks UI"
  },
  {
    "ruleId": "perf-web-workers",
    "ruleTitle": "Offload Heavy Computation to Web Workers",
    "type": "good",
    "code": "// ng generate web-worker data-processor\n\n// data-processor.worker.ts\naddEventListener('message', ({ data }) => {\n  const result = heavyComputation(data);\n  postMessage(result);\n});\n\n// data-processor.component.ts\n@Component({\n  template: `\n    <button (click)=\"processData()\" [disabled]=\"isProcessing()\">\n      {{ isProcessing() ? 'Processing...' : 'Process' }}\n    </button>\n    <div>Result: {{ result() }}</div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class DataProcessorComponent {\n  result = signal('');\n  isProcessing = signal(false);\n  private worker = new Worker(\n    new URL('./data-processor.worker', import.meta.url)\n  );\n\n  constructor() {\n    this.worker.onmessage = ({ data }) => {\n      this.result.set(data);\n      this.isProcessing.set(false);\n    };\n  }\n\n  processData() {\n    this.isProcessing.set(true);\n    this.worker.postMessage(this.generateLargeDataset());\n  }\n}",
    "language": "typescript",
    "description": "Web Worker keeps UI responsive"
  },
  {
    "ruleId": "rxjs-mapping-operators",
    "ruleTitle": "Use Correct RxJS Mapping Operators",
    "type": "bad",
    "code": "// ❌ mergeMap - All requests run parallel, results arrive out of order\nsearchControl.valueChanges.pipe(\n  mergeMap(query => this.searchService.search(query))\n).subscribe(results => {\n  this.results = results; // May show stale results from slow old request!\n});\n\n// ❌ concatMap - Queues all requests, user waits for old queries\nsearchControl.valueChanges.pipe(\n  concatMap(query => this.searchService.search(query))\n).subscribe(results => {\n  this.results = results; // Slow - waits for each request sequentially\n});",
    "language": "typescript",
    "description": "Wrong operator for search"
  },
  {
    "ruleId": "rxjs-mapping-operators",
    "ruleTitle": "Use Correct RxJS Mapping Operators",
    "type": "good",
    "code": "// ✅ switchMap - Cancels previous request, only latest matters\nsearchControl.valueChanges.pipe(\n  debounceTime(300),\n  distinctUntilChanged(),\n  switchMap(query => this.searchService.search(query))\n).subscribe(results => {\n  this.results = results; // Always shows results for latest query\n});",
    "language": "typescript",
    "description": "switchMap for search"
  },
  {
    "ruleId": "rxjs-mapping-operators",
    "ruleTitle": "Use Correct RxJS Mapping Operators",
    "type": "bad",
    "code": "// ❌ switchMap - User double-clicks, first submit is cancelled!\nsubmitForm$.pipe(\n  switchMap(() => this.orderService.placeOrder(this.form.value))\n).subscribe();\n// First order never placed if user clicks twice quickly\n\n// ❌ mergeMap - Both submits go through, duplicate orders!\nsubmitForm$.pipe(\n  mergeMap(() => this.orderService.placeOrder(this.form.value))\n).subscribe();\n// User gets charged twice",
    "language": "typescript",
    "description": "Wrong operator for form submit"
  },
  {
    "ruleId": "rxjs-mapping-operators",
    "ruleTitle": "Use Correct RxJS Mapping Operators",
    "type": "good",
    "code": "// ✅ exhaustMap - Ignores clicks while request is pending\nsubmitForm$.pipe(\n  exhaustMap(() => {\n    this.isSubmitting = true;\n    return this.orderService.placeOrder(this.form.value).pipe(\n      finalize(() => this.isSubmitting = false)\n    );\n  })\n).subscribe({\n  next: (order) => this.router.navigate(['/order', order.id]),\n  error: (err) => this.showError(err)\n});\n// Double-clicks ignored, only one order placed",
    "language": "typescript",
    "description": "exhaustMap for form submit"
  },
  {
    "ruleId": "rxjs-mapping-operators",
    "ruleTitle": "Use Correct RxJS Mapping Operators",
    "type": "bad",
    "code": "// ❌ switchMap - Later items cancel earlier ones!\nitemsToSave$.pipe(\n  switchMap(item => this.saveItem(item))\n).subscribe();\n// Only last item gets saved\n\n// ❌ mergeMap - Order not guaranteed, race conditions\nitemsToSave$.pipe(\n  mergeMap(item => this.saveItem(item))\n).subscribe();\n// Items may save out of order, causing data inconsistency",
    "language": "typescript",
    "description": "Wrong operator for sequential writes"
  },
  {
    "ruleId": "rxjs-mapping-operators",
    "ruleTitle": "Use Correct RxJS Mapping Operators",
    "type": "good",
    "code": "// ✅ concatMap - Each completes before next starts\nitemsToSave$.pipe(\n  concatMap(item => this.saveItem(item))\n).subscribe({\n  complete: () => console.log('All items saved in order')\n});\n// Guaranteed order: item1 saved, then item2, then item3...",
    "language": "typescript",
    "description": "concatMap for sequential writes"
  },
  {
    "ruleId": "rxjs-mapping-operators",
    "ruleTitle": "Use Correct RxJS Mapping Operators",
    "type": "good",
    "code": "// ✅ mergeMap - When order doesn't matter and parallel is faster\nnotificationIds$.pipe(\n  mergeMap(\n    id => this.markAsRead(id),\n    5 // Optional: limit concurrent requests to 5\n  )\n).subscribe();\n// All notifications marked as read in parallel, fastest completion",
    "language": "typescript",
    "description": "mergeMap for parallel independent operations"
  },
  {
    "ruleId": "rxjs-no-nested-subscribe",
    "ruleTitle": "Avoid Nested Subscriptions",
    "type": "bad",
    "code": "// ❌ Callback hell, inner subscription never cleaned up\n@Component({...})\nexport class OrderDetailsComponent implements OnInit {\n  ngOnInit() {\n    this.route.params.subscribe(params => {\n      this.orderService.getOrder(params['id']).subscribe(order => {\n        this.order = order;\n        this.userService.getUser(order.userId).subscribe(user => {\n          this.user = user;\n          this.addressService.getAddress(user.addressId).subscribe(address => {\n            this.address = address;\n            // 4 levels deep, impossible to maintain\n            // Memory leak: inner subscriptions never unsubscribed\n          });\n        });\n      });\n    });\n  }\n}",
    "language": "typescript",
    "description": "Nested subscriptions"
  },
  {
    "ruleId": "rxjs-no-nested-subscribe",
    "ruleTitle": "Avoid Nested Subscriptions",
    "type": "good",
    "code": "// ✅ Flat, readable, properly managed\n@Component({...})\nexport class OrderDetailsComponent implements OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  order$ = this.route.params.pipe(\n    map(params => params['id']),\n    switchMap(id => this.orderService.getOrder(id)),\n    takeUntil(this.destroy$)\n  );\n\n  user$ = this.order$.pipe(\n    switchMap(order => this.userService.getUser(order.userId))\n  );\n\n  address$ = this.user$.pipe(\n    switchMap(user => this.addressService.getAddress(user.addressId))\n  );\n\n  // Or combine all data into one stream\n  vm$ = this.route.params.pipe(\n    map(params => params['id']),\n    switchMap(id => this.orderService.getOrder(id)),\n    switchMap(order => forkJoin({\n      order: of(order),\n      user: this.userService.getUser(order.userId)\n    })),\n    switchMap(({ order, user }) => forkJoin({\n      order: of(order),\n      user: of(user),\n      address: this.addressService.getAddress(user.addressId)\n    })),\n    takeUntil(this.destroy$)\n  );\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}",
    "language": "typescript",
    "description": "Use operators to compose"
  },
  {
    "ruleId": "rxjs-no-nested-subscribe",
    "ruleTitle": "Avoid Nested Subscriptions",
    "type": "bad",
    "code": "// ❌ Nested subscribe for conditional fetch\nthis.authService.currentUser$.subscribe(user => {\n  if (user) {\n    this.userService.getProfile(user.id).subscribe(profile => {\n      this.profile = profile;\n    });\n  }\n});",
    "language": "typescript",
    "description": "Nested subscribe for conditional logic"
  },
  {
    "ruleId": "rxjs-no-nested-subscribe",
    "ruleTitle": "Avoid Nested Subscriptions",
    "type": "good",
    "code": "// ✅ Operators handle the conditional\nthis.authService.currentUser$.pipe(\n  filter((user): user is User => user !== null),\n  switchMap(user => this.userService.getProfile(user.id)),\n  takeUntilDestroyed()\n).subscribe(profile => {\n  this.profile = profile;\n});",
    "language": "typescript",
    "description": "Use filter and switchMap"
  },
  {
    "ruleId": "rxjs-no-nested-subscribe",
    "ruleTitle": "Avoid Nested Subscriptions",
    "type": "bad",
    "code": "// ❌ Subscribe just to call another method\nthis.items$.subscribe(items => {\n  this.processItems(items).subscribe(result => {\n    this.saveResult(result).subscribe(() => {\n      console.log('Done');\n    });\n  });\n});",
    "language": "typescript",
    "description": "Subscribe to trigger side effects"
  },
  {
    "ruleId": "rxjs-no-nested-subscribe",
    "ruleTitle": "Avoid Nested Subscriptions",
    "type": "good",
    "code": "// ✅ Single subscription with operator chain\nthis.items$.pipe(\n  concatMap(items => this.processItems(items)),\n  concatMap(result => this.saveResult(result)),\n  takeUntilDestroyed()\n).subscribe({\n  next: () => console.log('Done'),\n  error: (err) => console.error('Pipeline failed:', err)\n});",
    "language": "typescript",
    "description": "Chain with operators"
  },
  {
    "ruleId": "rxjs-operators",
    "ruleTitle": "Use Efficient RxJS Operators",
    "type": "bad",
    "code": "@Component({...})\nexport class SearchComponent {\n  searchControl = new FormControl('');\n\n  results$ = this.searchControl.valueChanges.pipe(\n    // mergeMap doesn't cancel previous requests\n    // Results can arrive out of order\n    mergeMap(query => this.searchService.search(query))\n  );\n}",
    "language": "typescript",
    "description": "mergeMap causes race conditions"
  },
  {
    "ruleId": "rxjs-operators",
    "ruleTitle": "Use Efficient RxJS Operators",
    "type": "good",
    "code": "@Component({\n  template: `\n    <input [formControl]=\"searchControl\" />\n    @for (result of results$ | async; track result.id) {\n      <div>{{ result.title }}</div>\n    }\n  `\n})\nexport class SearchComponent {\n  searchControl = new FormControl('');\n\n  results$ = this.searchControl.valueChanges.pipe(\n    debounceTime(300),                // Wait for typing to stop\n    distinctUntilChanged(),            // Skip if same value\n    filter(query => query.length > 2), // Min length\n    switchMap(query =>                 // Cancel previous request\n      this.searchService.search(query).pipe(\n        catchError(() => of([]))\n      )\n    )\n  );\n}",
    "language": "typescript",
    "description": "switchMap cancels previous, debounce reduces calls"
  },
  {
    "ruleId": "rxjs-share-replay",
    "ruleTitle": "Share Observables to Avoid Duplicate Requests",
    "type": "bad",
    "code": "@Component({\n  template: `\n    <!-- 3 async pipes = 3 HTTP requests! -->\n    <h1>{{ (user$ | async)?.name }}</h1>\n    <p>{{ (user$ | async)?.email }}</p>\n    <img [src]=\"(user$ | async)?.avatar\" />\n  `\n})\nexport class UserProfileComponent {\n  user$ = this.http.get<User>('/api/user');\n}",
    "language": "typescript",
    "description": "Each async pipe triggers separate request"
  },
  {
    "ruleId": "rxjs-share-replay",
    "ruleTitle": "Share Observables to Avoid Duplicate Requests",
    "type": "good",
    "code": "@Component({\n  template: `\n    @if (user$ | async; as user) {\n      <h1>{{ user.name }}</h1>\n      <p>{{ user.email }}</p>\n      <img [src]=\"user.avatar\" />\n    }\n  `\n})\nexport class UserProfileComponent {\n  user$ = this.http.get<User>('/api/user').pipe(\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n}",
    "language": "typescript",
    "description": "Share observable among subscribers"
  },
  {
    "ruleId": "template-no-function-calls",
    "ruleTitle": "Avoid Function Calls in Templates",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"user\">\n      <!-- getFullName() runs 100+ times on scroll, clicks, any event -->\n      <h2>{{ getFullName() }}</h2>\n      <span>{{ calculateAge(user.birthDate) }}</span>\n      <p>{{ formatAddress(user.address) }}</p>\n    </div>\n  `\n})\nexport class UserCardComponent {\n  @Input() user!: User;\n\n  getFullName(): string {\n    console.log('getFullName called'); // Logs hundreds of times!\n    return `${this.user.firstName} ${this.user.lastName}`;\n  }\n\n  calculateAge(birthDate: Date): number {\n    const today = new Date();\n    return today.getFullYear() - birthDate.getFullYear();\n  }\n\n  formatAddress(address: Address): string {\n    return `${address.street}, ${address.city}`;\n  }\n}",
    "language": "typescript",
    "description": "Function called on every cycle"
  },
  {
    "ruleId": "template-no-function-calls",
    "ruleTitle": "Avoid Function Calls in Templates",
    "type": "good",
    "code": "// Option 1: Pure Pipe (recommended for reusable transformations)\n@Pipe({ name: 'fullName', standalone: true, pure: true })\nexport class FullNamePipe implements PipeTransform {\n  transform(user: User): string {\n    return `${user.firstName} ${user.lastName}`;\n  }\n}\n\n@Pipe({ name: 'age', standalone: true, pure: true })\nexport class AgePipe implements PipeTransform {\n  transform(birthDate: Date): number {\n    return new Date().getFullYear() - birthDate.getFullYear();\n  }\n}\n\n@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"user\">\n      <!-- Pipes only run when input changes -->\n      <h2>{{ user | fullName }}</h2>\n      <span>{{ user.birthDate | age }}</span>\n      <p>{{ user.address.street }}, {{ user.address.city }}</p>\n    </div>\n  `,\n  imports: [FullNamePipe, AgePipe],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserCardComponent {\n  @Input() user!: User;\n}\n\n// Option 2: Computed signal (Angular 16+)\n@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"user\">\n      <h2>{{ fullName() }}</h2>\n      <span>{{ age() }}</span>\n    </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserCardComponent {\n  user = input.required<User>();\n\n  fullName = computed(() =>\n    `${this.user().firstName} ${this.user().lastName}`\n  );\n\n  age = computed(() =>\n    new Date().getFullYear() - this.user().birthDate.getFullYear()\n  );\n}",
    "language": "typescript",
    "description": "Use pipes or computed values"
  },
  {
    "ruleId": "template-virtual-scroll",
    "ruleTitle": "Use Virtual Scrolling for Large Lists",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-product-list',\n  template: `\n    <!-- 10,000 products = 10,000 DOM nodes = slow & memory hungry -->\n    <div class=\"product-list\">\n      @for (product of products; track product.id) {\n        <app-product-card [product]=\"product\" />\n      }\n    </div>\n  `\n})\nexport class ProductListComponent {\n  products: Product[] = []; // 10,000 items loaded\n}",
    "language": "typescript",
    "description": "Renders all items"
  },
  {
    "ruleId": "template-virtual-scroll",
    "ruleTitle": "Use Virtual Scrolling for Large Lists",
    "type": "good",
    "code": "import { ScrollingModule } from '@angular/cdk/scrolling';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <!-- Only ~10-20 visible items rendered at a time -->\n    <cdk-virtual-scroll-viewport\n      itemSize=\"80\"\n      class=\"product-list\"\n    >\n      <app-product-card\n        *cdkVirtualFor=\"let product of products; trackBy: trackById\"\n        [product]=\"product\"\n      />\n    </cdk-virtual-scroll-viewport>\n  `,\n  styles: [`\n    .product-list {\n      height: 600px; /* Fixed height required */\n      width: 100%;\n    }\n  `],\n  imports: [ScrollingModule],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ProductListComponent {\n  products: Product[] = []; // 10,000 items - no problem!\n\n  trackById(index: number, product: Product): number {\n    return product.id;\n  }\n}",
    "language": "typescript",
    "description": "Virtual scrolling"
  },
  {
    "ruleId": "bundle-defer-third-party",
    "ruleTitle": "Defer Non-Critical Third-Party Scripts",
    "type": "bad",
    "code": "// ❌ Analytics component loads in main bundle\nimport { AnalyticsComponent } from './analytics.component';\nimport { ChatWidgetComponent } from './chat-widget.component';\nimport { ErrorTrackingComponent } from './error-tracking.component';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <app-header />\n    <router-outlet />\n    <app-footer />\n\n    <!-- These load immediately, blocking TTI -->\n    <app-analytics />\n    <app-chat-widget />\n    <app-error-tracking />\n  `,\n  imports: [\n    AnalyticsComponent,      // Included in main bundle\n    ChatWidgetComponent,     // Included in main bundle\n    ErrorTrackingComponent   // Included in main bundle\n  ]\n})\nexport class AppComponent {}",
    "language": "typescript",
    "description": "blocks initial bundle"
  },
  {
    "ruleId": "bundle-defer-third-party",
    "ruleTitle": "Defer Non-Critical Third-Party Scripts",
    "type": "good",
    "code": "@Component({\n  selector: 'app-root',\n  template: `\n    <app-header />\n    <router-outlet />\n    <app-footer />\n\n    <!-- ✅ Loads AFTER hydration completes -->\n    @defer (on idle) {\n      <app-analytics />\n    }\n\n    @defer (on idle) {\n      <app-chat-widget />\n    }\n\n    @defer (on idle) {\n      <app-error-tracking />\n    }\n  `,\n  imports: [HeaderComponent, FooterComponent]\n  // Analytics, ChatWidget, ErrorTracking NOT in imports - loaded dynamically\n})\nexport class AppComponent {}",
    "language": "typescript",
    "description": "defer with @defer"
  },
  {
    "ruleId": "bundle-defer",
    "ruleTitle": "Use @defer for Lazy Loading Components",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-dashboard',\n  imports: [HeavyChartComponent, DataTableComponent],\n  template: `\n    <h1>Dashboard</h1>\n\n    <!-- Chart library loaded even if user never scrolls down -->\n    <app-heavy-chart [data]=\"chartData\" />\n\n    <!-- Large table always in initial bundle -->\n    <app-data-table [rows]=\"tableData\" />\n  `\n})\nexport class DashboardComponent {}",
    "language": "typescript",
    "description": "Heavy components loaded immediately"
  },
  {
    "ruleId": "bundle-defer",
    "ruleTitle": "Use @defer for Lazy Loading Components",
    "type": "good",
    "code": "@Component({\n  selector: 'app-dashboard',\n  imports: [HeavyChartComponent, DataTableComponent],\n  template: `\n    <h1>Dashboard</h1>\n\n    @defer (on viewport) {\n      <app-heavy-chart [data]=\"chartData\" />\n    } @placeholder {\n      <div class=\"chart-skeleton\">Loading chart...</div>\n    }\n\n    @defer (on interaction) {\n      <app-data-table [rows]=\"tableData\" />\n    } @placeholder {\n      <button>Click to load data table</button>\n    }\n  `\n})\nexport class DashboardComponent {}",
    "language": "typescript",
    "description": "Defer loading until needed"
  },
  {
    "ruleId": "bundle-lazy-routes",
    "ruleTitle": "Lazy Load Routes with loadComponent",
    "type": "bad",
    "code": "import { DashboardComponent } from './dashboard/dashboard.component';\nimport { SettingsComponent } from './settings/settings.component';\nimport { ReportsComponent } from './reports/reports.component';\n\nexport const routes: Routes = [\n  { path: '', component: DashboardComponent },\n  { path: 'settings', component: SettingsComponent },\n  { path: 'reports', component: ReportsComponent }\n  // All components loaded upfront, even if never visited\n];",
    "language": "typescript",
    "description": "Eagerly loaded routes"
  },
  {
    "ruleId": "bundle-lazy-routes",
    "ruleTitle": "Lazy Load Routes with loadComponent",
    "type": "good",
    "code": "export const routes: Routes = [\n  {\n    path: '',\n    loadComponent: () =>\n      import('./dashboard/dashboard.component').then(m => m.DashboardComponent)\n  },\n  {\n    path: 'settings',\n    loadComponent: () =>\n      import('./settings/settings.component').then(m => m.SettingsComponent)\n  },\n  {\n    path: 'reports',\n    loadChildren: () =>\n      import('./reports/reports.routes').then(m => m.REPORTS_ROUTES)\n  }\n];",
    "language": "typescript",
    "description": "Lazy loaded routes"
  },
  {
    "ruleId": "bundle-preload",
    "ruleTitle": "Use Preload Strategies for Lazy Modules",
    "type": "bad",
    "code": "export const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(routes)\n    // No preloading - modules load on demand\n    // User experiences delay on first navigation\n  ]\n};",
    "language": "typescript",
    "description": "No preloading causes navigation delay"
  },
  {
    "ruleId": "bundle-preload",
    "ruleTitle": "Use Preload Strategies for Lazy Modules",
    "type": "good",
    "code": "import { provideRouter, withPreloading, PreloadAllModules } from '@angular/router';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(\n      routes,\n      withPreloading(PreloadAllModules)\n    )\n  ]\n};",
    "language": "typescript",
    "description": "Preload all modules after initial load"
  },
  {
    "ruleId": "bundle-standalone",
    "ruleTitle": "Use Standalone Components",
    "type": "bad",
    "code": "@NgModule({\n  declarations: [UserListComponent, UserDetailComponent],\n  imports: [CommonModule, SharedModule],\n  exports: [UserListComponent]\n})\nexport class UserModule {}\n\n@Component({\n  selector: 'app-user-list',\n  template: `...`\n})\nexport class UserListComponent {}\n// Dependencies come from module - not explicit",
    "language": "typescript",
    "description": "NgModule-based with implicit dependencies"
  },
  {
    "ruleId": "bundle-standalone",
    "ruleTitle": "Use Standalone Components",
    "type": "good",
    "code": "@Component({\n  selector: 'app-user-list',\n  // No standalone: true needed in v19+\n  imports: [RouterLink, UserAvatarComponent],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    @for (user of users(); track user.id) {\n      <app-user-avatar [user]=\"user\" />\n      <a [routerLink]=\"['/users', user.id]\">{{ user.name }}</a>\n    }\n  `\n})\nexport class UserListComponent {\n  private userService = inject(UserService);\n  users = toSignal(this.userService.getUsers(), { initialValue: [] });\n}",
    "language": "typescript",
    "description": "Standalone with explicit imports"
  },
  {
    "ruleId": "change-signals",
    "ruleTitle": "Use Angular Signals for Reactive State",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-counter',\n  template: `\n    <p>Count: {{ count }}</p>\n    <p>Double: {{ count * 2 }}</p>\n    <button (click)=\"increment()\">+</button>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class CounterComponent {\n  count = 0;\n\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  increment() {\n    this.count++;\n    this.cdr.markForCheck(); // Manual trigger required\n  }\n}",
    "language": "typescript",
    "description": "Manual change detection with OnPush"
  },
  {
    "ruleId": "change-signals",
    "ruleTitle": "Use Angular Signals for Reactive State",
    "type": "good",
    "code": "@Component({\n  selector: 'app-counter',\n  template: `\n    <p>Count: {{ count() }}</p>\n    <p>Double: {{ doubleCount() }}</p>\n    <button (click)=\"increment()\">+</button>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class CounterComponent {\n  count = signal(0);\n  doubleCount = computed(() => this.count() * 2);\n\n  increment() {\n    this.count.update(c => c + 1);\n    // No markForCheck needed - signals handle it automatically\n  }\n}",
    "language": "typescript",
    "description": "Signals with automatic change detection"
  },
  {
    "ruleId": "component-signal-io",
    "ruleTitle": "Use Signal Inputs and Outputs",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-user-card',\n  template: `\n    <h2>{{ name }}</h2>\n    <p>{{ email }}</p>\n    <button (click)=\"onSelect()\">Select</button>\n  `\n})\nexport class UserCardComponent implements OnChanges {\n  @Input() name!: string;\n  @Input() email = '';\n  @Output() selected = new EventEmitter<string>();\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['name']) {\n      console.log('Name changed:', this.name);\n    }\n  }\n\n  onSelect() {\n    this.selected.emit(this.name);\n  }\n}",
    "language": "typescript",
    "description": "Decorator-based with OnChanges"
  },
  {
    "ruleId": "component-signal-io",
    "ruleTitle": "Use Signal Inputs and Outputs",
    "type": "good",
    "code": "@Component({\n  selector: 'app-user-card',\n  template: `\n    <h2>{{ name() }}</h2>\n    <p>{{ email() }}</p>\n    <button (click)=\"handleClick()\">Select</button>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserCardComponent {\n  name = input.required<string>();\n  email = input('');\n  selected = output<string>();\n\n  constructor() {\n    effect(() => {\n      console.log('Name changed:', this.name());\n    });\n  }\n\n  handleClick() {\n    this.selected.emit(this.name());\n  }\n}",
    "language": "typescript",
    "description": "Signal inputs with effect"
  },
  {
    "ruleId": "di-factory-providers",
    "ruleTitle": "Use Factory Providers for Complex Setup",
    "type": "bad",
    "code": "@Injectable({ providedIn: 'root' })\nexport class StorageService {\n  private storage: Storage;\n\n  constructor() {\n    // Complex logic in constructor - hard to test\n    if (typeof window !== 'undefined' && window.localStorage) {\n      this.storage = window.localStorage;\n    } else {\n      this.storage = new MemoryStorage();\n    }\n  }\n}",
    "language": "typescript",
    "description": "Complex logic in constructor"
  },
  {
    "ruleId": "di-factory-providers",
    "ruleTitle": "Use Factory Providers for Complex Setup",
    "type": "good",
    "code": "export abstract class StorageService {\n  abstract getItem(key: string): string | null;\n  abstract setItem(key: string, value: string): void;\n}\n\nexport class LocalStorageService extends StorageService {\n  getItem(key: string) { return localStorage.getItem(key); }\n  setItem(key: string, value: string) { localStorage.setItem(key, value); }\n}\n\nexport class MemoryStorageService extends StorageService {\n  private store = new Map<string, string>();\n  getItem(key: string) { return this.store.get(key) ?? null; }\n  setItem(key: string, value: string) { this.store.set(key, value); }\n}\n\n// app.config.ts\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    {\n      provide: StorageService,\n      useFactory: () => {\n        const platformId = inject(PLATFORM_ID);\n        return isPlatformBrowser(platformId)\n          ? new LocalStorageService()\n          : new MemoryStorageService();\n      }\n    }\n  ]\n};",
    "language": "typescript"
  },
  {
    "ruleId": "di-injection-token",
    "ruleTitle": "Use InjectionToken for Type-Safe Configuration",
    "type": "bad",
    "code": "providers: [\n  { provide: 'API_URL', useValue: 'https://api.example.com' }\n]\n\n@Injectable({ providedIn: 'root' })\nexport class ApiService {\n  private apiUrl = inject('API_URL' as any);  // No type safety\n}",
    "language": "typescript",
    "description": "String tokens lose type safety"
  },
  {
    "ruleId": "di-injection-token",
    "ruleTitle": "Use InjectionToken for Type-Safe Configuration",
    "type": "good",
    "code": "// tokens.ts\nexport interface AppConfig {\n  apiUrl: string;\n  timeout: number;\n}\n\nexport const APP_CONFIG = new InjectionToken<AppConfig>('app.config');\n\n// app.config.ts\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    {\n      provide: APP_CONFIG,\n      useValue: { apiUrl: 'https://api.example.com', timeout: 5000 }\n    }\n  ]\n};\n\n// api.service.ts\n@Injectable({ providedIn: 'root' })\nexport class ApiService {\n  private config = inject(APP_CONFIG);  // Fully typed as AppConfig\n}",
    "language": "typescript"
  },
  {
    "ruleId": "di-provided-in-root",
    "ruleTitle": "Use providedIn root for Tree-Shaking",
    "type": "bad",
    "code": "@Injectable()\nexport class UserService {}\n\n@NgModule({\n  providers: [UserService]  // Always in bundle, even if unused\n})\nexport class UserModule {}",
    "language": "typescript",
    "description": "Service always in bundle"
  },
  {
    "ruleId": "di-provided-in-root",
    "ruleTitle": "Use providedIn root for Tree-Shaking",
    "type": "good",
    "code": "@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private http = inject(HttpClient);\n\n  getUsers(): Observable<User[]> {\n    return this.http.get<User[]>('/api/users');\n  }\n}\n\n// No providers array needed - just inject where used\n@Component({...})\nexport class UserListComponent {\n  private userService = inject(UserService);\n  users = toSignal(this.userService.getUsers(), { initialValue: [] });\n}",
    "language": "typescript"
  },
  {
    "ruleId": "directive-host-composition",
    "ruleTitle": "Use Host Directives for Behavior Composition",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-button',\n  template: `<ng-content />`\n})\nexport class ButtonComponent {\n  @HostBinding('class.focused') isFocused = false;\n  @HostBinding('class.disabled') isDisabled = false;\n\n  @HostListener('focus') onFocus() { this.isFocused = true; }\n  @HostListener('blur') onBlur() { this.isFocused = false; }\n}\n\n@Component({\n  selector: 'app-card',\n  template: `<ng-content />`\n})\nexport class CardComponent {\n  // Same focus/disable logic duplicated...\n  @HostBinding('class.focused') isFocused = false;\n  @HostBinding('class.disabled') isDisabled = false;\n}",
    "language": "typescript",
    "description": "Repeated behavior across components"
  },
  {
    "ruleId": "directive-host-composition",
    "ruleTitle": "Use Host Directives for Behavior Composition",
    "type": "good",
    "code": "@Directive({\n  selector: '[focusable]',\n  host: {\n    'tabindex': '0',\n    '(focus)': 'onFocus()',\n    '(blur)': 'onBlur()',\n    '[class.focused]': 'isFocused()'\n  }\n})\nexport class FocusableDirective {\n  isFocused = signal(false);\n  onFocus() { this.isFocused.set(true); }\n  onBlur() { this.isFocused.set(false); }\n}\n\n@Component({\n  selector: 'app-button',\n  hostDirectives: [FocusableDirective],\n  template: `<ng-content />`\n})\nexport class ButtonComponent {}\n\n@Component({\n  selector: 'app-card',\n  hostDirectives: [FocusableDirective],\n  template: `<ng-content />`\n})\nexport class CardComponent {}",
    "language": "typescript",
    "description": "Reusable behavior directive"
  },
  {
    "ruleId": "forms-reactive",
    "ruleTitle": "Use Reactive Forms for Complex Forms",
    "type": "bad",
    "code": "@Component({\n  template: `\n    <form #userForm=\"ngForm\" (ngSubmit)=\"onSubmit()\">\n      <input [(ngModel)]=\"user.email\" name=\"email\" required email />\n      <input [(ngModel)]=\"user.password\" name=\"password\" required />\n      <input [(ngModel)]=\"user.confirmPassword\" name=\"confirmPassword\" />\n\n      <!-- Complex validation in template -->\n      @if (userForm.controls['password']?.value !== userForm.controls['confirmPassword']?.value) {\n        <div>Passwords don't match</div>\n      }\n    </form>\n  `\n})\nexport class RegisterComponent {\n  user = { email: '', password: '', confirmPassword: '' };\n}",
    "language": "typescript",
    "description": "Template-driven with complex validation"
  },
  {
    "ruleId": "forms-reactive",
    "ruleTitle": "Use Reactive Forms for Complex Forms",
    "type": "good",
    "code": "@Component({\n  imports: [ReactiveFormsModule],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">\n      <input formControlName=\"email\" />\n      <input type=\"password\" formControlName=\"password\" />\n      <input type=\"password\" formControlName=\"confirmPassword\" />\n\n      @if (form.errors?.['passwordMismatch']) {\n        <span class=\"error\">Passwords don't match</span>\n      }\n\n      <button [disabled]=\"form.invalid\">Submit</button>\n    </form>\n  `\n})\nexport class RegisterComponent {\n  private fb = inject(NonNullableFormBuilder);\n\n  form = this.fb.group({\n    email: ['', [Validators.required, Validators.email]],\n    password: ['', [Validators.required, Validators.minLength(8)]],\n    confirmPassword: ['', Validators.required]\n  }, {\n    validators: [this.passwordMatchValidator]\n  });\n\n  passwordMatchValidator(group: FormGroup): ValidationErrors | null {\n    const password = group.get('password')?.value;\n    const confirm = group.get('confirmPassword')?.value;\n    return password === confirm ? null : { passwordMismatch: true };\n  }\n\n  onSubmit() {\n    if (this.form.valid) {\n      const { email, password } = this.form.getRawValue();\n    }\n  }\n}",
    "language": "typescript",
    "description": "Reactive form with typed controls"
  },
  {
    "ruleId": "http-interceptors",
    "ruleTitle": "Use Functional HTTP Interceptors",
    "type": "bad",
    "code": "@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(private authService: AuthService) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const token = this.authService.getToken();\n    if (token) {\n      req = req.clone({\n        setHeaders: { Authorization: `Bearer ${token}` }\n      });\n    }\n    return next.handle(req);\n  }\n}\n\n// Registration requires verbose provider config\nproviders: [\n  { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }\n]",
    "language": "typescript",
    "description": "Class-based interceptor"
  },
  {
    "ruleId": "http-interceptors",
    "ruleTitle": "Use Functional HTTP Interceptors",
    "type": "good",
    "code": "export const authInterceptor: HttpInterceptorFn = (req, next) => {\n  const authService = inject(AuthService);\n  const token = authService.getToken();\n\n  if (token) {\n    req = req.clone({\n      setHeaders: { Authorization: `Bearer ${token}` }\n    });\n  }\n\n  return next(req);\n};\n\n// app.config.ts - Clean registration\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(\n      withInterceptors([authInterceptor])\n    )\n  ]\n};",
    "language": "typescript",
    "description": "Functional interceptor"
  },
  {
    "ruleId": "http-resource",
    "ruleTitle": "Use httpResource for Signal-Based HTTP",
    "type": "bad",
    "code": "@Component({\n  template: `\n    @if (loading) {\n      <p>Loading...</p>\n    } @else if (error) {\n      <p>Error: {{ error }}</p>\n    } @else {\n      <p>{{ user?.name }}</p>\n    }\n  `\n})\nexport class UserComponent implements OnInit {\n  user: User | null = null;\n  loading = false;\n  error: string | null = null;\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    this.loading = true;\n    this.http.get<User>('/api/users/1').subscribe({\n      next: (user) => {\n        this.user = user;\n        this.loading = false;\n      },\n      error: (err) => {\n        this.error = err.message;\n        this.loading = false;\n      }\n    });\n  }\n}",
    "language": "typescript",
    "description": "Manual loading state management"
  },
  {
    "ruleId": "http-resource",
    "ruleTitle": "Use httpResource for Signal-Based HTTP",
    "type": "good",
    "code": "@Component({\n  template: `\n    @if (userResource.isLoading()) {\n      <p>Loading...</p>\n    } @else if (userResource.error()) {\n      <p>Error: {{ userResource.error()?.message }}</p>\n      <button (click)=\"userResource.reload()\">Retry</button>\n    } @else if (userResource.hasValue()) {\n      <h1>{{ userResource.value().name }}</h1>\n    }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserComponent {\n  userId = signal('123');\n\n  // Auto-refetches when userId changes\n  userResource = httpResource<User>(() => `/api/users/${this.userId()}`);\n}",
    "language": "typescript",
    "description": "httpResource with automatic state"
  },
  {
    "ruleId": "http-transfer-state",
    "ruleTitle": "Use TransferState for SSR Hydration",
    "type": "bad",
    "code": "@Component({...})\nexport class ProductListComponent implements OnInit {\n  products$!: Observable<Product[]>;\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    // Runs on server AND client = 2 identical requests\n    this.products$ = this.http.get<Product[]>('/api/products');\n  }\n}",
    "language": "typescript",
    "description": "Duplicate requests during hydration"
  },
  {
    "ruleId": "http-transfer-state",
    "ruleTitle": "Use TransferState for SSR Hydration",
    "type": "good",
    "code": "// app.config.ts\nimport { provideClientHydration, withHttpTransferCacheOptions } from '@angular/platform-browser';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(withFetch()),\n    provideClientHydration(\n      withHttpTransferCacheOptions({\n        includePostRequests: true\n      })\n    )\n  ]\n};\n\n// component.ts - No changes needed\n@Component({...})\nexport class ProductListComponent {\n  products$ = inject(HttpClient).get<Product[]>('/api/products');\n  // Response transferred from server to client automatically\n}",
    "language": "typescript",
    "description": "Enable HTTP cache transfer"
  },
  {
    "ruleId": "routing-signal-inputs",
    "ruleTitle": "Use Signal Inputs for Route Parameters",
    "type": "bad",
    "code": "@Component({\n  template: `<h1>User {{ userId }}</h1>`\n})\nexport class UserDetailComponent implements OnInit, OnDestroy {\n  userId: string | null = null;\n  private subscription?: Subscription;\n\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    this.subscription = this.route.paramMap.subscribe((params) => {\n      this.userId = params.get('id');\n    });\n  }\n\n  ngOnDestroy() {\n    this.subscription?.unsubscribe();\n  }\n}",
    "language": "typescript",
    "description": "Manual route parameter subscription"
  },
  {
    "ruleId": "routing-signal-inputs",
    "ruleTitle": "Use Signal Inputs for Route Parameters",
    "type": "good",
    "code": "// app.config.ts - Enable input binding\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(routes, withComponentInputBinding())\n  ]\n};\n\n// Route: { path: 'users/:id', component: UserDetailComponent }\n@Component({\n  template: `<h1>User {{ id() }}</h1>`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserDetailComponent {\n  id = input.required<string>();  // Route param auto-bound\n  userId = computed(() => parseInt(this.id(), 10));\n}",
    "language": "typescript",
    "description": "Signal input for route params"
  },
  {
    "ruleId": "rxjs-async-pipe",
    "ruleTitle": "Use Async Pipe Instead of Manual Subscribe",
    "type": "bad",
    "code": "@Component({\n  template: `\n    @if (user) {\n      <h1>{{ user.name }}</h1>\n    }\n  `\n})\nexport class UserProfileComponent implements OnInit, OnDestroy {\n  user: User | null = null;\n  private subscription!: Subscription;\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    this.subscription = this.userService.getCurrentUser()\n      .subscribe(user => this.user = user);\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();  // Easy to forget\n  }\n}",
    "language": "typescript",
    "description": "Manual subscription with leak potential"
  },
  {
    "ruleId": "rxjs-async-pipe",
    "ruleTitle": "Use Async Pipe Instead of Manual Subscribe",
    "type": "good",
    "code": "@Component({\n  imports: [AsyncPipe],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    @if (user$ | async; as user) {\n      <h1>{{ user.name }}</h1>\n    }\n  `\n})\nexport class UserProfileComponent {\n  user$ = inject(UserService).getCurrentUser();\n  // No manual subscribe/unsubscribe needed\n}",
    "language": "typescript",
    "description": "Async pipe handles lifecycle"
  },
  {
    "ruleId": "rxjs-takeuntil",
    "ruleTitle": "Use takeUntilDestroyed for Cleanup",
    "type": "bad",
    "code": "@Component({...})\nexport class DataComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  ngOnInit() {\n    this.dataService.getData()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(data => this.processData(data));\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n    // Boilerplate, easy to forget\n  }\n}",
    "language": "typescript",
    "description": "Manual Subject-based cleanup"
  },
  {
    "ruleId": "rxjs-takeuntil",
    "ruleTitle": "Use takeUntilDestroyed for Cleanup",
    "type": "good",
    "code": "@Component({...})\nexport class DataComponent {\n  constructor() {\n    // In constructor, DestroyRef is auto-injected\n    this.dataService.getData()\n      .pipe(takeUntilDestroyed())\n      .subscribe(data => this.processData(data));\n  }\n}\n\n// Or outside constructor:\nexport class DataComponent implements OnInit {\n  private destroyRef = inject(DestroyRef);\n\n  ngOnInit() {\n    this.dataService.getData()\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe(data => this.processData(data));\n  }\n}",
    "language": "typescript",
    "description": "takeUntilDestroyed handles cleanup"
  },
  {
    "ruleId": "signal-computed-pure",
    "ruleTitle": "Keep computed() Pure - No Side Effects",
    "type": "bad",
    "code": "// ❌ Side effects: logging, DOM manipulation, HTTP calls\n@Component({...})\nexport class ProductListComponent {\n  products = signal<Product[]>([]);\n\n  // BAD: Console log runs multiple times unexpectedly\n  totalPrice = computed(() => {\n    console.log('Calculating total...'); // Side effect!\n    return this.products().reduce((sum, p) => sum + p.price, 0);\n  });\n\n  // BAD: Mutating external state\n  processedProducts = computed(() => {\n    this.analyticsService.track('products-viewed'); // Side effect!\n    return this.products().filter(p => p.active);\n  });\n\n  // BAD: Async operations (will NOT work)\n  enrichedProducts = computed(async () => { // DON'T DO THIS\n    const products = this.products();\n    return await this.enrichData(products); // Signals are synchronous!\n  });\n}",
    "language": "typescript",
    "description": "Side effects in computed"
  },
  {
    "ruleId": "signal-computed-pure",
    "ruleTitle": "Keep computed() Pure - No Side Effects",
    "type": "good",
    "code": "@Component({...})\nexport class ProductListComponent {\n  products = signal<Product[]>([]);\n\n  // ✅ Pure computed - only derives new value\n  totalPrice = computed(() =>\n    this.products().reduce((sum, p) => sum + p.price, 0)\n  );\n\n  // ✅ Pure computed - filter is a pure operation\n  activeProducts = computed(() =>\n    this.products().filter(p => p.active)\n  );\n\n  // ✅ Use effect() for side effects\n  constructor() {\n    effect(() => {\n      const products = this.products();\n      console.log(`Products updated: ${products.length} items`);\n      this.analyticsService.track('products-viewed', { count: products.length });\n    });\n  }\n}",
    "language": "typescript",
    "description": "Pure computed, effects for side effects"
  },
  {
    "ruleId": "signal-computed-pure",
    "ruleTitle": "Keep computed() Pure - No Side Effects",
    "type": "bad",
    "code": "// ❌ Mutating the array directly\n@Component({...})\nexport class TodoComponent {\n  todos = signal<Todo[]>([]);\n\n  sortedTodos = computed(() => {\n    const items = this.todos();\n    items.sort((a, b) => a.priority - b.priority); // Mutates original!\n    return items;\n  });\n}",
    "language": "typescript",
    "description": "Mutating signal values"
  },
  {
    "ruleId": "signal-computed-pure",
    "ruleTitle": "Keep computed() Pure - No Side Effects",
    "type": "good",
    "code": "// ✅ Create new array, don't mutate\n@Component({...})\nexport class TodoComponent {\n  todos = signal<Todo[]>([]);\n\n  sortedTodos = computed(() =>\n    [...this.todos()].sort((a, b) => a.priority - b.priority)\n    // Or use toSorted() in modern JS\n    // this.todos().toSorted((a, b) => a.priority - b.priority)\n  );\n\n  // ✅ Using spread for objects\n  todosWithStatus = computed(() =>\n    this.todos().map(todo => ({\n      ...todo,\n      statusLabel: todo.done ? 'Complete' : 'Pending'\n    }))\n  );\n}",
    "language": "typescript",
    "description": "Immutable operations"
  },
  {
    "ruleId": "signal-computed-pure",
    "ruleTitle": "Keep computed() Pure - No Side Effects",
    "type": "bad",
    "code": "// ❌ Heavy computation runs on every access\n@Component({...})\nexport class DataGridComponent {\n  data = signal<Row[]>([]);\n  filter = signal('');\n\n  // Problem: Complex filtering runs every time filteredData() is accessed\n  filteredData = computed(() => {\n    return this.data()\n      .filter(row => this.matchesFilter(row, this.filter()))\n      .sort((a, b) => this.complexSort(a, b))\n      .map(row => this.transformRow(row));\n  });\n}",
    "language": "typescript",
    "description": "Expensive operations without memoization"
  },
  {
    "ruleId": "signal-computed-pure",
    "ruleTitle": "Keep computed() Pure - No Side Effects",
    "type": "good",
    "code": "// ✅ Chain computed signals - each only recomputes when its deps change\n@Component({...})\nexport class DataGridComponent {\n  data = signal<Row[]>([]);\n  filter = signal('');\n  sortField = signal<keyof Row>('name');\n\n  // Each step is memoized independently\n  filteredData = computed(() =>\n    this.data().filter(row =>\n      row.name.toLowerCase().includes(this.filter().toLowerCase())\n    )\n  );\n\n  sortedData = computed(() =>\n    [...this.filteredData()].sort((a, b) =>\n      String(a[this.sortField()]).localeCompare(String(b[this.sortField()]))\n    )\n  );\n\n  // Only re-transforms when sortedData changes\n  displayData = computed(() =>\n    this.sortedData().map(row => ({\n      ...row,\n      displayName: `${row.firstName} ${row.lastName}`\n    }))\n  );\n}",
    "language": "typescript",
    "description": "Break into smaller computed signals"
  },
  {
    "ruleId": "signal-computed-pure",
    "ruleTitle": "Keep computed() Pure - No Side Effects",
    "type": "good",
    "code": "@Component({...})\nexport class ExamplesComponent {\n  user = signal<User | null>(null);\n  items = signal<Item[]>([]);\n  searchTerm = signal('');\n\n  // ✅ Derive boolean state\n  isLoggedIn = computed(() => this.user() !== null);\n\n  // ✅ Derive formatted values\n  displayName = computed(() => {\n    const user = this.user();\n    return user ? `${user.firstName} ${user.lastName}` : 'Guest';\n  });\n\n  // ✅ Filter/map operations\n  visibleItems = computed(() =>\n    this.items().filter(item =>\n      item.name.toLowerCase().includes(this.searchTerm().toLowerCase())\n    )\n  );\n\n  // ✅ Aggregate calculations\n  stats = computed(() => ({\n    total: this.items().length,\n    visible: this.visibleItems().length,\n    avgPrice: this.items().reduce((s, i) => s + i.price, 0) / this.items().length || 0\n  }));\n\n  // ✅ Combine multiple signals\n  viewModel = computed(() => ({\n    user: this.user(),\n    items: this.visibleItems(),\n    stats: this.stats(),\n    isLoggedIn: this.isLoggedIn()\n  }));\n}",
    "language": "typescript"
  },
  {
    "ruleId": "signal-effect-patterns",
    "ruleTitle": "Use effect() Correctly - Avoid Anti-Patterns",
    "type": "bad",
    "code": "// ❌ INFINITE LOOP - effect reads count, then writes to count\n@Component({...})\nexport class CounterComponent {\n  count = signal(0);\n\n  constructor() {\n    effect(() => {\n      // Reads count, triggers effect\n      // Writes count, triggers effect again\n      // Infinite loop!\n      this.count.set(this.count() + 1);\n    });\n  }\n}",
    "language": "typescript",
    "description": "Writing to a signal you're reading"
  },
  {
    "ruleId": "signal-effect-patterns",
    "ruleTitle": "Use effect() Correctly - Avoid Anti-Patterns",
    "type": "good",
    "code": "// ✅ Use computed for derived values\n@Component({...})\nexport class CounterComponent {\n  count = signal(0);\n  doubledCount = computed(() => this.count() * 2); // No effect needed!\n\n  increment() {\n    this.count.update(c => c + 1);\n  }\n}",
    "language": "typescript",
    "description": "Use computed or direct update"
  },
  {
    "ruleId": "signal-effect-patterns",
    "ruleTitle": "Use effect() Correctly - Avoid Anti-Patterns",
    "type": "bad",
    "code": "// ❌ Memory leak - inner effect never destroyed\n@Component({...})\nexport class BadComponent {\n  user = signal<User | null>(null);\n\n  constructor() {\n    effect(() => {\n      const user = this.user();\n      if (user) {\n        // Creates new effect on EVERY user change\n        // Old effects never cleaned up!\n        effect(() => {\n          console.log('Nested effect:', user.name);\n        });\n      }\n    });\n  }\n}",
    "language": "typescript",
    "description": "Nested effects"
  },
  {
    "ruleId": "signal-effect-patterns",
    "ruleTitle": "Use effect() Correctly - Avoid Anti-Patterns",
    "type": "good",
    "code": "// ✅ One effect, conditional inside\n@Component({...})\nexport class GoodComponent {\n  user = signal<User | null>(null);\n\n  constructor() {\n    effect(() => {\n      const user = this.user();\n      if (user) {\n        console.log('User logged in:', user.name);\n        this.analyticsService.identify(user.id);\n      } else {\n        console.log('User logged out');\n        this.analyticsService.reset();\n      }\n    });\n  }\n}",
    "language": "typescript",
    "description": "Single effect with conditional logic"
  },
  {
    "ruleId": "signal-effect-patterns",
    "ruleTitle": "Use effect() Correctly - Avoid Anti-Patterns",
    "type": "bad",
    "code": "// ❌ Anti-pattern: effect to derive state\n@Component({...})\nexport class BadSyncComponent {\n  firstName = signal('');\n  lastName = signal('');\n  fullName = signal(''); // Should be computed!\n\n  constructor() {\n    // DON'T: Use effect to sync signals\n    effect(() => {\n      this.fullName.set(`${this.firstName()} ${this.lastName()}`);\n    }, { allowSignalWrites: true });\n  }\n}",
    "language": "typescript",
    "description": "Using effect to sync state"
  },
  {
    "ruleId": "signal-effect-patterns",
    "ruleTitle": "Use effect() Correctly - Avoid Anti-Patterns",
    "type": "good",
    "code": "// ✅ computed is the right tool for derived values\n@Component({...})\nexport class GoodSyncComponent {\n  firstName = signal('');\n  lastName = signal('');\n  fullName = computed(() => `${this.firstName()} ${this.lastName()}`);\n}",
    "language": "typescript",
    "description": "Use computed for derived state"
  },
  {
    "ruleId": "signal-effect-patterns",
    "ruleTitle": "Use effect() Correctly - Avoid Anti-Patterns",
    "type": "bad",
    "code": "// ❌ Anti-pattern: calling child methods from parent effect\n@Component({\n  template: `<app-child #child />`\n})\nexport class BadParentComponent {\n  data = signal<Data | null>(null);\n  @ViewChild('child') child!: ChildComponent;\n\n  constructor() {\n    effect(() => {\n      const data = this.data();\n      if (data) {\n        this.child.updateData(data); // Imperative, fragile\n      }\n    });\n  }\n}",
    "language": "typescript",
    "description": "Effect for parent-to-child communication"
  },
  {
    "ruleId": "signal-effect-patterns",
    "ruleTitle": "Use effect() Correctly - Avoid Anti-Patterns",
    "type": "good",
    "code": "// ✅ Declarative data flow with inputs\n@Component({\n  template: `<app-child [data]=\"data()\" />`\n})\nexport class GoodParentComponent {\n  data = signal<Data | null>(null);\n}\n\n// Child receives data reactively via input\n@Component({...})\nexport class ChildComponent {\n  data = input<Data | null>(null);\n\n  processedData = computed(() => {\n    const d = this.data();\n    return d ? this.process(d) : null;\n  });\n}",
    "language": "typescript",
    "description": "Use input binding"
  },
  {
    "ruleId": "signal-effect-patterns",
    "ruleTitle": "Use effect() Correctly - Avoid Anti-Patterns",
    "type": "good",
    "code": "@Component({...})\nexport class CorrectEffectUsageComponent {\n  theme = signal<'light' | 'dark'>('light');\n  searchQuery = signal('');\n  user = signal<User | null>(null);\n\n  constructor() {\n    // ✅ Sync with external API (DOM, localStorage, etc.)\n    effect(() => {\n      document.body.classList.toggle('dark-mode', this.theme() === 'dark');\n    });\n\n    // ✅ Persist to localStorage\n    effect(() => {\n      localStorage.setItem('theme', this.theme());\n    });\n\n    // ✅ Logging/Analytics (non-reactive world)\n    effect(() => {\n      const user = this.user();\n      if (user) {\n        this.analytics.identify(user.id);\n      }\n    });\n\n    // ✅ Trigger imperative APIs\n    effect(() => {\n      const query = this.searchQuery();\n      if (query.length > 0) {\n        this.autocomplete.updateSuggestions(query);\n      }\n    });\n  }\n}",
    "language": "typescript"
  },
  {
    "ruleId": "signal-linkedsignal",
    "ruleTitle": "Use linkedSignal for Derived + Writable State",
    "type": "good",
    "code": "// ✅ Advanced: Keep selection if it's still in the new list\n@Component({...})\nexport class SmartSelectorComponent {\n  options = signal<Option[]>([]);\n\n  selectedOption = linkedSignal({\n    source: this.options,\n    computation: (options, previous) => {\n      // If previous selection is still valid, keep it\n      if (previous && options.some(o => o.id === previous.id)) {\n        return previous;\n      }\n      // Otherwise, select first option\n      return options[0] ?? null;\n    }\n  });\n}",
    "language": "typescript",
    "description": "linkedSignal"
  },
  {
    "ruleId": "signal-linkedsignal",
    "ruleTitle": "Use linkedSignal for Derived + Writable State",
    "type": "bad",
    "code": "// ❌ Anti-pattern: effect to sync derived state\n@Component({...})\nexport class BadComponent {\n  source = signal<string[]>([]);\n  selected = signal<string | null>(null);\n\n  constructor() {\n    effect(() => {\n      const items = this.source();\n      this.selected.set(items[0] ?? null);\n    }, { allowSignalWrites: true }); // Avoid this!\n  }\n}",
    "language": "typescript",
    "description": "effect with allowSignalWrites"
  },
  {
    "ruleId": "signal-linkedsignal",
    "ruleTitle": "Use linkedSignal for Derived + Writable State",
    "type": "good",
    "code": "// ✅ linkedSignal is designed for this exact use case\n@Component({...})\nexport class GoodComponent {\n  source = signal<string[]>([]);\n  selected = linkedSignal(() => this.source()[0] ?? null);\n}",
    "language": "typescript",
    "description": "linkedSignal"
  },
  {
    "ruleId": "ssr-hydration",
    "ruleTitle": "Use Incremental Hydration for SSR",
    "type": "bad",
    "code": "@Component({\n  template: `\n    <app-header />\n    <app-hero />\n    <app-comments [postId]=\"postId\" />      <!-- Heavy, below fold -->\n    <app-recommendations />                  <!-- Heavy, below fold -->\n    <app-footer />\n  `\n})\nexport class PostComponent {\n  postId = input.required<string>();\n}",
    "language": "typescript",
    "description": "Full hydration of all components"
  },
  {
    "ruleId": "ssr-hydration",
    "ruleTitle": "Use Incremental Hydration for SSR",
    "type": "good",
    "code": "@Component({\n  template: `\n    <app-header />\n    <app-hero />\n\n    @defer (hydrate on viewport) {\n      <app-comments [postId]=\"postId()\" />\n    } @placeholder {\n      <div class=\"comments-skeleton\">Loading comments...</div>\n    }\n\n    @defer (hydrate on idle) {\n      <app-recommendations />\n    }\n\n    @defer (hydrate never) {\n      <app-footer />\n    }\n  `\n})\nexport class PostComponent {\n  postId = input.required<string>();\n}",
    "language": "typescript",
    "description": "Incremental hydration with @defer"
  },
  {
    "ruleId": "template-ng-optimized-image",
    "ruleTitle": "Use NgOptimizedImage for Images",
    "type": "bad",
    "code": "<!-- No lazy loading, no priority hints, potential CLS -->\n<img src=\"/assets/hero.jpg\" alt=\"Hero image\">\n\n<!-- May cause layout shift without dimensions -->\n<img src=\"{{ user.avatar }}\" alt=\"User avatar\">",
    "language": "html",
    "description": "Native img without optimization"
  },
  {
    "ruleId": "template-ng-optimized-image",
    "ruleTitle": "Use NgOptimizedImage for Images",
    "type": "good",
    "code": "@Component({\n  imports: [NgOptimizedImage],\n  template: `\n    <!-- Priority image (above fold, LCP candidate) -->\n    <img\n      ngSrc=\"/assets/hero.jpg\"\n      alt=\"Hero image\"\n      width=\"1200\"\n      height=\"600\"\n      priority\n    />\n\n    <!-- Lazy loaded by default (below fold) -->\n    <img\n      [ngSrc]=\"user().avatar\"\n      alt=\"User avatar\"\n      width=\"64\"\n      height=\"64\"\n    />\n  `\n})\nexport class ProductComponent {\n  user = input.required<User>();\n}",
    "language": "typescript",
    "description": "NgOptimizedImage with best practices"
  },
  {
    "ruleId": "template-pure-pipes",
    "ruleTitle": "Use Pure Pipes for Data Transformation",
    "type": "bad",
    "code": "@Component({\n  template: `\n    @for (product of products; track product.id) {\n      <!-- formatPrice called on EVERY change detection cycle -->\n      <span>{{ formatPrice(product.price) }}</span>\n    }\n  `\n})\nexport class ProductListComponent {\n  formatPrice(price: number): string {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: 'USD'\n    }).format(price);\n  }\n}",
    "language": "typescript",
    "description": "Method called on every change detection"
  },
  {
    "ruleId": "template-pure-pipes",
    "ruleTitle": "Use Pure Pipes for Data Transformation",
    "type": "good",
    "code": "@Pipe({ name: 'price' })\nexport class PricePipe implements PipeTransform {\n  transform(value: number, currency = 'USD'): string {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency\n    }).format(value);\n  }\n}\n\n@Component({\n  imports: [PricePipe],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    @for (product of products; track product.id) {\n      <span>{{ product.price | price }}</span>\n    }\n  `\n})\nexport class ProductListComponent {\n  products = signal<Product[]>([]);\n}",
    "language": "typescript",
    "description": "Pure pipe only runs when input changes"
  },
  {
    "ruleId": "template-trackby",
    "ruleTitle": "Use @for with track for Loops",
    "type": "bad",
    "code": "@Component({\n  template: `\n    <!-- All items re-render when array changes -->\n    <div *ngFor=\"let user of users\">\n      <app-user-card [user]=\"user\" />\n    </div>\n  `\n})\nexport class UserListComponent {\n  users: User[] = [];\n}",
    "language": "typescript",
    "description": "No tracking causes full DOM recreation"
  },
  {
    "ruleId": "template-trackby",
    "ruleTitle": "Use @for with track for Loops",
    "type": "good",
    "code": "@Component({\n  template: `\n    @for (user of users(); track user.id) {\n      <app-user-card [user]=\"user\" />\n    } @empty {\n      <p>No users found</p>\n    }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserListComponent {\n  users = signal<User[]>([]);\n}",
    "language": "typescript",
    "description": "@for with required track"
  },
  {
    "ruleId": "bundle-lazy-routes",
    "ruleTitle": "Lazy Load Feature Modules",
    "type": "bad",
    "code": "import { UserModule } from './user/user.module';\nimport { AdminModule } from './admin/admin.module';\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes),\n    UserModule,   // Loaded immediately\n    AdminModule   // Loaded even if user never visits\n  ]\n})\nexport class AppRoutingModule {}",
    "language": "typescript",
    "description": "Eagerly loaded modules"
  },
  {
    "ruleId": "bundle-lazy-routes",
    "ruleTitle": "Lazy Load Feature Modules",
    "type": "good",
    "code": "const routes: Routes = [\n  {\n    path: 'users',\n    loadChildren: () =>\n      import('./user/user.module').then(m => m.UserModule)\n  },\n  {\n    path: 'admin',\n    loadChildren: () =>\n      import('./admin/admin.module').then(m => m.AdminModule),\n    canLoad: [AuthGuard]\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}",
    "language": "typescript",
    "description": "Lazy loaded modules"
  },
  {
    "ruleId": "bundle-ngmodule",
    "ruleTitle": "Organize Code with Feature Modules",
    "type": "bad",
    "code": "@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    UserListComponent,\n    UserDetailComponent,\n    ProductListComponent,\n    ProductDetailComponent,\n    CartComponent,\n    CheckoutComponent,\n    // ... 50 more components\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    FormsModule,\n    ReactiveFormsModule,\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n// Everything loaded upfront, huge initial bundle",
    "language": "typescript",
    "description": "Everything in AppModule"
  },
  {
    "ruleId": "bundle-ngmodule",
    "ruleTitle": "Organize Code with Feature Modules",
    "type": "good",
    "code": "// user.module.ts\n@NgModule({\n  declarations: [\n    UserListComponent,\n    UserDetailComponent,\n    UserAvatarComponent,\n  ],\n  imports: [\n    CommonModule,\n    UserRoutingModule,\n    SharedModule,\n  ]\n})\nexport class UserModule {}\n\n// product.module.ts\n@NgModule({\n  declarations: [\n    ProductListComponent,\n    ProductDetailComponent,\n  ],\n  imports: [\n    CommonModule,\n    ProductRoutingModule,\n    SharedModule,\n  ]\n})\nexport class ProductModule {}\n\n// app-routing.module.ts\nconst routes: Routes = [\n  {\n    path: 'users',\n    loadChildren: () => import('./user/user.module').then(m => m.UserModule)\n  },\n  {\n    path: 'products',\n    loadChildren: () => import('./product/product.module').then(m => m.ProductModule)\n  }\n];\n\n// app.module.ts - minimal\n@NgModule({\n  declarations: [AppComponent, HeaderComponent, FooterComponent],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    AppRoutingModule,\n    CoreModule, // Singleton services\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}",
    "language": "typescript",
    "description": "Feature modules with lazy loading"
  },
  {
    "ruleId": "bundle-preload",
    "ruleTitle": "Use Preload Strategies for Lazy Modules",
    "type": "bad",
    "code": "@NgModule({\n  imports: [RouterModule.forRoot(routes)]\n  // No preloading - modules load on demand with delay\n})\nexport class AppRoutingModule {}",
    "language": "typescript",
    "description": "No preloading causes navigation delay"
  },
  {
    "ruleId": "bundle-preload",
    "ruleTitle": "Use Preload Strategies for Lazy Modules",
    "type": "good",
    "code": "import { PreloadAllModules } from '@angular/router';\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, {\n      preloadingStrategy: PreloadAllModules\n    })\n  ]\n})\nexport class AppRoutingModule {}",
    "language": "typescript",
    "description": "Preload all modules"
  },
  {
    "ruleId": "bundle-scam",
    "ruleTitle": "Use SCAM Pattern Instead of Shared Modules",
    "type": "bad",
    "code": "// shared.module.ts\n@NgModule({\n  declarations: [\n    ButtonComponent,\n    CardComponent,\n    ModalComponent,\n    TooltipDirective,\n    DatePipe,\n    CurrencyPipe,\n    // 20+ more components...\n  ],\n  exports: [\n    ButtonComponent,\n    CardComponent,\n    ModalComponent,\n    TooltipDirective,\n    DatePipe,\n    CurrencyPipe,\n    // All exported even if only one is used\n  ]\n})\nexport class SharedModule {}\n\n// feature.module.ts\n@NgModule({\n  imports: [SharedModule] // Imports ALL shared components\n})\nexport class FeatureModule {}",
    "language": "typescript",
    "description": "Shared module with many exports"
  },
  {
    "ruleId": "bundle-scam",
    "ruleTitle": "Use SCAM Pattern Instead of Shared Modules",
    "type": "good",
    "code": "// button/button.component.module.ts\n@NgModule({\n  declarations: [ButtonComponent],\n  imports: [CommonModule],\n  exports: [ButtonComponent]\n})\nexport class ButtonComponentModule {}\n\n// card/card.component.module.ts\n@NgModule({\n  declarations: [CardComponent],\n  imports: [CommonModule],\n  exports: [CardComponent]\n})\nexport class CardComponentModule {}\n\n// modal/modal.component.module.ts\n@NgModule({\n  declarations: [ModalComponent],\n  imports: [CommonModule, ButtonComponentModule],\n  exports: [ModalComponent]\n})\nexport class ModalComponentModule {}\n\n// tooltip/tooltip.directive.module.ts\n@NgModule({\n  declarations: [TooltipDirective],\n  exports: [TooltipDirective]\n})\nexport class TooltipDirectiveModule {}\n\n// feature.module.ts\n@NgModule({\n  imports: [\n    ButtonComponentModule,  // Only import what you need\n    CardComponentModule\n  ]\n})\nexport class FeatureModule {}",
    "language": "typescript",
    "description": "SCAM pattern"
  },
  {
    "ruleId": "change-rxjs-state",
    "ruleTitle": "Use BehaviorSubject for Reactive State",
    "type": "bad",
    "code": "@Component({\n  selector: 'app-counter',\n  template: `\n    <p>Count: {{ count }}</p>\n    <p>Double: {{ count * 2 }}</p>\n    <button (click)=\"increment()\">+</button>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class CounterComponent {\n  count = 0;\n\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  increment() {\n    this.count++;\n    this.cdr.markForCheck(); // Manual trigger required\n  }\n}",
    "language": "typescript",
    "description": "Imperative state with manual change detection"
  },
  {
    "ruleId": "change-rxjs-state",
    "ruleTitle": "Use BehaviorSubject for Reactive State",
    "type": "good",
    "code": "@Component({\n  selector: 'app-counter',\n  template: `\n    <ng-container *ngIf=\"vm$ | async as vm\">\n      <p>Count: {{ vm.count }}</p>\n      <p>Double: {{ vm.double }}</p>\n    </ng-container>\n    <button (click)=\"increment()\">+</button>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class CounterComponent {\n  private countSubject = new BehaviorSubject<number>(0);\n\n  vm$ = this.countSubject.pipe(\n    map(count => ({\n      count,\n      double: count * 2\n    }))\n  );\n\n  increment() {\n    this.countSubject.next(this.countSubject.value + 1);\n    // No manual markForCheck needed - async pipe handles it\n  }\n}",
    "language": "typescript",
    "description": "BehaviorSubject with async pipe"
  },
  {
    "ruleId": "di-factory-providers",
    "ruleTitle": "Use Factory Providers for Complex Setup",
    "type": "bad",
    "code": "@Injectable({ providedIn: 'root' })\nexport class StorageService {\n  private storage: Storage;\n\n  constructor() {\n    // Complex logic in constructor - hard to test\n    if (typeof window !== 'undefined' && window.localStorage) {\n      this.storage = window.localStorage;\n    } else {\n      this.storage = new MemoryStorage();\n    }\n  }\n}",
    "language": "typescript",
    "description": "Complex logic in constructor"
  },
  {
    "ruleId": "di-factory-providers",
    "ruleTitle": "Use Factory Providers for Complex Setup",
    "type": "good",
    "code": "export abstract class StorageService {\n  abstract getItem(key: string): string | null;\n  abstract setItem(key: string, value: string): void;\n}\n\nexport class LocalStorageService extends StorageService {\n  getItem(key: string) { return localStorage.getItem(key); }\n  setItem(key: string, value: string) { localStorage.setItem(key, value); }\n}\n\nexport class MemoryStorageService extends StorageService {\n  private store = new Map<string, string>();\n  getItem(key: string) { return this.store.get(key) ?? null; }\n  setItem(key: string, value: string) { this.store.set(key, value); }\n}\n\n// app.module.ts\n@NgModule({\n  providers: [\n    {\n      provide: StorageService,\n      useFactory: (platformId: object) => {\n        return isPlatformBrowser(platformId)\n          ? new LocalStorageService()\n          : new MemoryStorageService();\n      },\n      deps: [PLATFORM_ID]\n    }\n  ]\n})\nexport class AppModule {}",
    "language": "typescript",
    "description": "Factory provider with deps array"
  },
  {
    "ruleId": "di-injection-token",
    "ruleTitle": "Use InjectionToken for Type-Safe Configuration",
    "type": "bad",
    "code": "@NgModule({\n  providers: [\n    { provide: 'API_URL', useValue: 'https://api.example.com' }\n  ]\n})\nexport class AppModule {}\n\n@Injectable({ providedIn: 'root' })\nexport class ApiService {\n  constructor(@Inject('API_URL') private apiUrl: any) {}  // No type safety\n}",
    "language": "typescript",
    "description": "String tokens lose type safety"
  },
  {
    "ruleId": "di-injection-token",
    "ruleTitle": "Use InjectionToken for Type-Safe Configuration",
    "type": "good",
    "code": "// tokens.ts\nexport interface AppConfig {\n  apiUrl: string;\n  timeout: number;\n}\n\nexport const APP_CONFIG = new InjectionToken<AppConfig>('app.config');\n\n// app.module.ts\n@NgModule({\n  providers: [\n    {\n      provide: APP_CONFIG,\n      useValue: { apiUrl: 'https://api.example.com', timeout: 5000 }\n    }\n  ]\n})\nexport class AppModule {}\n\n// api.service.ts\n@Injectable({ providedIn: 'root' })\nexport class ApiService {\n  constructor(@Inject(APP_CONFIG) private config: AppConfig) {}  // Typed!\n}",
    "language": "typescript",
    "description": "InjectionToken with @Inject"
  },
  {
    "ruleId": "di-provided-in-root",
    "ruleTitle": "Use providedIn root for Tree-Shaking",
    "type": "bad",
    "code": "@Injectable()\nexport class UserService {}\n\n@NgModule({\n  providers: [UserService]  // Always in bundle, even if unused\n})\nexport class UserModule {}",
    "language": "typescript",
    "description": "Service always in bundle"
  },
  {
    "ruleId": "di-provided-in-root",
    "ruleTitle": "Use providedIn root for Tree-Shaking",
    "type": "good",
    "code": "@Injectable({ providedIn: 'root' })\nexport class UserService {\n  constructor(private http: HttpClient) {}\n\n  getUsers(): Observable<User[]> {\n    return this.http.get<User[]>('/api/users');\n  }\n}\n\n// Inject in constructor\n@Component({...})\nexport class UserListComponent implements OnInit {\n  users$!: Observable<User[]>;\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    this.users$ = this.userService.getUsers();\n  }\n}",
    "language": "typescript",
    "description": "Tree-shakeable with constructor injection"
  },
  {
    "ruleId": "forms-reactive",
    "ruleTitle": "Use Reactive Forms for Complex Forms",
    "type": "bad",
    "code": "@Component({\n  template: `\n    <form #userForm=\"ngForm\" (ngSubmit)=\"onSubmit()\">\n      <input [(ngModel)]=\"user.email\" name=\"email\" required email />\n      <input [(ngModel)]=\"user.password\" name=\"password\" required />\n      <input [(ngModel)]=\"user.confirmPassword\" name=\"confirmPassword\" />\n\n      <div *ngIf=\"userForm.controls['password']?.value !== userForm.controls['confirmPassword']?.value\">\n        Passwords don't match\n      </div>\n    </form>\n  `\n})\nexport class RegisterComponent {\n  user = { email: '', password: '', confirmPassword: '' };\n}",
    "language": "typescript",
    "description": "Template-driven with complex validation"
  },
  {
    "ruleId": "forms-reactive",
    "ruleTitle": "Use Reactive Forms for Complex Forms",
    "type": "good",
    "code": "@Component({\n  template: `\n    <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">\n      <input formControlName=\"email\" />\n      <input type=\"password\" formControlName=\"password\" />\n      <input type=\"password\" formControlName=\"confirmPassword\" />\n\n      <div *ngIf=\"form.errors?.['passwordMismatch']\" class=\"error\">\n        Passwords don't match\n      </div>\n\n      <button [disabled]=\"form.invalid\">Submit</button>\n    </form>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class RegisterComponent implements OnInit {\n  form!: FormGroup;\n\n  constructor(private fb: FormBuilder) {}\n\n  ngOnInit() {\n    this.form = this.fb.group({\n      email: ['', [Validators.required, Validators.email]],\n      password: ['', [Validators.required, Validators.minLength(8)]],\n      confirmPassword: ['', Validators.required]\n    }, {\n      validators: [this.passwordMatchValidator]\n    });\n  }\n\n  passwordMatchValidator(group: FormGroup): ValidationErrors | null {\n    const password = group.get('password')?.value;\n    const confirm = group.get('confirmPassword')?.value;\n    return password === confirm ? null : { passwordMismatch: true };\n  }\n}",
    "language": "typescript",
    "description": "Reactive form with FormBuilder"
  },
  {
    "ruleId": "forms-typed",
    "ruleTitle": "Use Typed Reactive Forms (v14+)",
    "type": "bad",
    "code": "@Component({...})\nexport class ProfileComponent {\n  form = new FormGroup({\n    name: new FormControl(''),\n    email: new FormControl(''),\n    age: new FormControl(0)\n  });\n\n  onSubmit() {\n    const value = this.form.value;\n    // value is Partial<{name: string | null, ...}>\n    // Type is loose, nullable, and partial\n    console.log(value.nmae); // Typo not caught\n  }\n}",
    "language": "typescript",
    "description": "Untyped form"
  },
  {
    "ruleId": "forms-typed",
    "ruleTitle": "Use Typed Reactive Forms (v14+)",
    "type": "good",
    "code": "interface ProfileForm {\n  name: FormControl<string>;\n  email: FormControl<string>;\n  age: FormControl<number>;\n}\n\n@Component({\n  template: `\n    <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">\n      <input formControlName=\"name\" />\n      <input formControlName=\"email\" type=\"email\" />\n      <input formControlName=\"age\" type=\"number\" />\n      <button [disabled]=\"form.invalid\">Save</button>\n    </form>\n  `\n})\nexport class ProfileComponent {\n  form: FormGroup<ProfileForm>;\n\n  constructor(private fb: NonNullableFormBuilder) {\n    this.form = this.fb.group({\n      name: ['', Validators.required],\n      email: ['', [Validators.required, Validators.email]],\n      age: [0, [Validators.required, Validators.min(0)]]\n    });\n  }\n\n  onSubmit() {\n    // getRawValue() returns fully typed, non-nullable object\n    const value = this.form.getRawValue();\n    // Type: { name: string; email: string; age: number }\n\n    // Compile error: Property 'nmae' does not exist\n    // console.log(value.nmae);\n\n    this.saveProfile(value);\n  }\n\n  // Safe typed access\n  get nameControl() {\n    return this.form.controls.name; // FormControl<string>\n  }\n}",
    "language": "typescript",
    "description": "Typed form with NonNullableFormBuilder"
  },
  {
    "ruleId": "http-interceptors",
    "ruleTitle": "Use Class-Based HTTP Interceptors",
    "type": "bad",
    "code": "@Injectable({ providedIn: 'root' })\nexport class UserService {\n  constructor(private http: HttpClient, private authService: AuthService) {}\n\n  getUsers(): Observable<User[]> {\n    // Auth header added manually in every method\n    const headers = new HttpHeaders().set(\n      'Authorization', `Bearer ${this.authService.getToken()}`\n    );\n    return this.http.get<User[]>('/api/users', { headers });\n  }\n}",
    "language": "typescript",
    "description": "Duplicated auth logic in services"
  },
  {
    "ruleId": "http-interceptors",
    "ruleTitle": "Use Class-Based HTTP Interceptors",
    "type": "good",
    "code": "@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(private authService: AuthService) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const token = this.authService.getToken();\n    if (token) {\n      req = req.clone({\n        setHeaders: { Authorization: `Bearer ${token}` }\n      });\n    }\n    return next.handle(req);\n  }\n}\n\n// app.module.ts\n@NgModule({\n  providers: [\n    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }\n  ]\n})\nexport class AppModule {}\n\n// Services are now clean\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  constructor(private http: HttpClient) {}\n\n  getUsers(): Observable<User[]> {\n    return this.http.get<User[]>('/api/users');  // No auth logic needed\n  }\n}",
    "language": "typescript",
    "description": "Class-based interceptor"
  },
  {
    "ruleId": "http-transfer-state",
    "ruleTitle": "Use TransferState for SSR",
    "type": "bad",
    "code": "@Component({...})\nexport class ProductListComponent implements OnInit {\n  products: Product[] = [];\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    // Runs on server AND client = 2 requests\n    this.http.get<Product[]>('/api/products')\n      .subscribe(products => this.products = products);\n  }\n}",
    "language": "typescript",
    "description": "Duplicate requests"
  },
  {
    "ruleId": "http-transfer-state",
    "ruleTitle": "Use TransferState for SSR",
    "type": "good",
    "code": "import { TransferState, makeStateKey } from '@angular/platform-browser';\nimport { isPlatformServer } from '@angular/common';\n\nconst PRODUCTS_KEY = makeStateKey<Product[]>('products');\n\n@Component({\n  template: `\n    <div *ngFor=\"let product of products; trackBy: trackById\">\n      {{ product.name }}\n    </div>\n  `\n})\nexport class ProductListComponent implements OnInit {\n  products: Product[] = [];\n\n  constructor(\n    private http: HttpClient,\n    private transferState: TransferState,\n    @Inject(PLATFORM_ID) private platformId: Object\n  ) {}\n\n  ngOnInit() {\n    // Check if data was transferred from server\n    if (this.transferState.hasKey(PRODUCTS_KEY)) {\n      this.products = this.transferState.get(PRODUCTS_KEY, []);\n      this.transferState.remove(PRODUCTS_KEY);\n    } else {\n      this.http.get<Product[]>('/api/products').subscribe(products => {\n        this.products = products;\n        // Store on server for client\n        if (isPlatformServer(this.platformId)) {\n          this.transferState.set(PRODUCTS_KEY, products);\n        }\n      });\n    }\n  }\n\n  trackById = (index: number, product: Product) => product.id;\n}",
    "language": "typescript",
    "description": "Manual TransferState"
  },
  {
    "ruleId": "rxjs-async-pipe",
    "ruleTitle": "Use Async Pipe Instead of Manual Subscribe",
    "type": "bad",
    "code": "@Component({\n  template: `\n    <div *ngIf=\"user\">\n      <h1>{{ user.name }}</h1>\n    </div>\n  `\n})\nexport class UserProfileComponent implements OnInit, OnDestroy {\n  user: User | null = null;\n  private subscription!: Subscription;\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    this.subscription = this.userService.getCurrentUser()\n      .subscribe(user => this.user = user);\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();  // Easy to forget\n  }\n}",
    "language": "typescript",
    "description": "Manual subscription"
  },
  {
    "ruleId": "rxjs-async-pipe",
    "ruleTitle": "Use Async Pipe Instead of Manual Subscribe",
    "type": "good",
    "code": "@Component({\n  template: `\n    <div *ngIf=\"user$ | async as user\">\n      <h1>{{ user.name }}</h1>\n    </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserProfileComponent {\n  user$ = this.userService.getCurrentUser();\n\n  constructor(private userService: UserService) {}\n  // No manual subscribe/unsubscribe needed\n}",
    "language": "typescript",
    "description": "Async pipe handles lifecycle"
  },
  {
    "ruleId": "rxjs-takeuntil",
    "ruleTitle": "Use Subject with takeUntil for Cleanup",
    "type": "bad",
    "code": "@Component({...})\nexport class DataComponent implements OnInit, OnDestroy {\n  private sub1!: Subscription;\n  private sub2!: Subscription;\n\n  ngOnInit() {\n    this.sub1 = this.dataService.getData()\n      .subscribe(data => this.processData(data));\n    this.sub2 = this.eventService.events$\n      .subscribe(event => this.handleEvent(event));\n  }\n\n  ngOnDestroy() {\n    this.sub1.unsubscribe();  // Easy to forget one\n    this.sub2.unsubscribe();\n  }\n}",
    "language": "typescript",
    "description": "Manual subscription management"
  },
  {
    "ruleId": "rxjs-takeuntil",
    "ruleTitle": "Use Subject with takeUntil for Cleanup",
    "type": "good",
    "code": "@Component({...})\nexport class DataComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  ngOnInit() {\n    this.dataService.getData()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(data => this.processData(data));\n\n    this.eventService.events$\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(event => this.handleEvent(event));\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}",
    "language": "typescript",
    "description": "Subject with takeUntil pattern"
  },
  {
    "ruleId": "template-ng-optimized-image",
    "ruleTitle": "Use NgOptimizedImage for Images (v15+)",
    "type": "bad",
    "code": "<img src=\"/assets/hero.jpg\" alt=\"Hero image\">\n<img src=\"{{ user.avatar }}\" alt=\"User avatar\">",
    "language": "html",
    "description": "Native img"
  },
  {
    "ruleId": "template-ng-optimized-image",
    "ruleTitle": "Use NgOptimizedImage for Images (v15+)",
    "type": "good",
    "code": "// app.module.ts\nimport { NgOptimizedImage } from '@angular/common';\n\n@NgModule({\n  imports: [NgOptimizedImage]\n})\nexport class AppModule {}\n\n// component.ts\n@Component({\n  template: `\n    <!-- Priority image (LCP candidate) -->\n    <img\n      ngSrc=\"/assets/hero.jpg\"\n      alt=\"Hero image\"\n      width=\"1200\"\n      height=\"600\"\n      priority\n    />\n\n    <!-- Lazy loaded (below fold) -->\n    <img\n      [ngSrc]=\"user.avatar\"\n      alt=\"User avatar\"\n      width=\"64\"\n      height=\"64\"\n    />\n\n    <!-- Fill mode -->\n    <div class=\"image-container\">\n      <img\n        ngSrc=\"/assets/product.jpg\"\n        alt=\"Product\"\n        fill\n        sizes=\"(max-width: 768px) 100vw, 50vw\"\n      />\n    </div>\n  `,\n  styles: [`\n    .image-container {\n      position: relative;\n      width: 100%;\n      aspect-ratio: 4/3;\n    }\n  `]\n})\nexport class ProductComponent {}",
    "language": "typescript",
    "description": "NgOptimizedImage"
  },
  {
    "ruleId": "template-pure-pipes",
    "ruleTitle": "Use Pure Pipes for Data Transformation",
    "type": "bad",
    "code": "@Component({\n  template: `\n    <div *ngFor=\"let product of products; trackBy: trackById\">\n      <span>{{ formatPrice(product.price) }}</span>\n    </div>\n  `\n})\nexport class ProductListComponent {\n  formatPrice(price: number): string {\n    // Called on EVERY change detection cycle\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: 'USD'\n    }).format(price);\n  }\n}",
    "language": "typescript",
    "description": "Method called on every change detection"
  },
  {
    "ruleId": "template-pure-pipes",
    "ruleTitle": "Use Pure Pipes for Data Transformation",
    "type": "good",
    "code": "@Pipe({ name: 'price' })\nexport class PricePipe implements PipeTransform {\n  transform(value: number, currency = 'USD'): string {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency\n    }).format(value);\n  }\n}\n\n@Component({\n  template: `\n    <div *ngFor=\"let product of products; trackBy: trackById\">\n      <span>{{ product.price | price }}</span>\n    </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ProductListComponent {\n  trackById = (index: number, product: Product) => product.id;\n}",
    "language": "typescript",
    "description": "Pure pipe only runs when input changes"
  },
  {
    "ruleId": "template-trackby",
    "ruleTitle": "Use trackBy with *ngFor",
    "type": "bad",
    "code": "@Component({\n  template: `\n    <div *ngFor=\"let user of users\">\n      <app-user-card [user]=\"user\"></app-user-card>\n    </div>\n  `\n})\nexport class UserListComponent {\n  users: User[] = [];\n\n  refresh() {\n    // New array = all DOM destroyed and recreated\n    this.users = [...this.fetchedUsers];\n  }\n}",
    "language": "typescript",
    "description": "DOM recreated on every update"
  },
  {
    "ruleId": "template-trackby",
    "ruleTitle": "Use trackBy with *ngFor",
    "type": "good",
    "code": "@Component({\n  template: `\n    <div *ngFor=\"let user of users; trackBy: trackById\">\n      <app-user-card [user]=\"user\"></app-user-card>\n    </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserListComponent {\n  users: User[] = [];\n\n  trackById(index: number, user: User): number {\n    return user.id;\n  }\n}",
    "language": "typescript",
    "description": "trackBy enables DOM reuse"
  }
]